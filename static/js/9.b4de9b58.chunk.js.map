{"version":3,"sources":["../node_modules/canvas-sketch-util/lib/wrap.js","../node_modules/canvas-sketch-util/math.js","../node_modules/point-in-polygon/index.js","utils/geometry.js","../node_modules/vec2-copy/index.js","utils/shape.js","../node_modules/chaikin-smooth/index.js","sketches/013_tree/index.js"],"names":["module","exports","value","from","to","TypeError","t","cycle","Math","floor","defined","require","wrap","EPSILON","Number","clamp","min","max","lerp","inverseLerp","abs","toFinite","n","defaultValue","isFinite","expandVector","dims","p","scalar","i","out","lerpArray","length","newArray","initialValue","push","mod","a","b","damp","lambda","dt","exp","fract","sign","degToRad","PI","radToDeg","pingPong","linspace","opts","endpoint","offset","map","_","lerpFrames","values","len","whole","frame","nextFrame","Array","isArray","clamp01","v","smoothstep","x","dampArray","mapRange","inputMin","inputMax","outputMin","outputMax","outVal","expand2D","expand3D","expand4D","point","vs","y","inside","j","xi","yi","xj","yj","isPointBetween","findSegmentIntersection","p1","p2","p3","p4","i1","findIntersection","pointsDistance","p1x","p1y","p2x","p2y","sqrt","getPointCoordsByAngleAndDistance","angle","distance","initPoint","xC","cos","yC","sin","isCircleInCircle","c1","c2","x0","y0","r0","x1","y1","r1","auto","hypot","twoCirclesIntersection","getCoordinates","dx","dy","d","x2","y2","h","rx","ry","xiPrime","yiPrime","circeIntersectWithCircles","circle","anotherCircles","intersect","aCircle","r","rope","coords","lineContour1","lineContour2","forEach","idx","pB","atan2","rotate","reverse","smoothPath","path","level","chaikinSmooth","circleTree","maxTriesFindNewPoint","tension","newBranchTension","maxGenerations","minRadius","reduceRadiusFactor","maxBends","subTreesFromNode","limitPolygon","reduceRadiusOnFail","newPointSearchAngel","newBranchSearchAngel","allPoints","branches","makeBranch","beforePoint","generation","branch","isRoot","bPoint","tries","foundPoint","rad","random","range","pointInsidePolygon","comparingPoints","filter","slice","copy","input","output","p0","p0x","p0y","Q","R","seed","getRandomSeed","setSeed","sketch","width","height","margin","sx","sy","prevTime","context","time","playhead","tree","fillStyle","fillRect","strokeStyle","branchIdx","branchCoords","ropeCoords","beginPath","moveTo","lineTo","closePath","fill","settings","dimensions","animate"],"mappings":"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","file":"static/js/9.b4de9b58.chunk.js","sourcesContent":["module.exports = wrap;\nfunction wrap (value, from, to) {\n  if (typeof from !== 'number' || typeof to !== 'number') {\n    throw new TypeError('Must specify \"to\" and \"from\" arguments as numbers');\n  }\n  // algorithm from http://stackoverflow.com/a/5852628/599884\n  if (from > to) {\n    var t = from;\n    from = to;\n    to = t;\n  }\n  var cycle = to - from;\n  if (cycle === 0) {\n    return to;\n  }\n  return value - cycle * Math.floor((value - from) / cycle);\n}\n","var defined = require('defined');\nvar wrap = require('./lib/wrap');\nvar EPSILON = Number.EPSILON;\n\nfunction clamp (value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value);\n}\n\nfunction clamp01 (v) {\n  return clamp(v, 0, 1);\n}\n\nfunction lerp (min, max, t) {\n  return min * (1 - t) + max * t;\n}\n\nfunction inverseLerp (min, max, t) {\n  if (Math.abs(min - max) < EPSILON) return 0;\n  else return (t - min) / (max - min);\n}\n\nfunction smoothstep (min, max, t) {\n  var x = clamp(inverseLerp(min, max, t), 0, 1);\n  return x * x * (3 - 2 * x);\n}\n\nfunction toFinite (n, defaultValue) {\n  defaultValue = defined(defaultValue, 0);\n  return typeof n === 'number' && isFinite(n) ? n : defaultValue;\n}\n\nfunction expandVector (dims) {\n  if (typeof dims !== 'number') throw new TypeError('Expected dims argument');\n  return function (p, defaultValue) {\n    defaultValue = defined(defaultValue, 0);\n    var scalar;\n    if (p == null) {\n      // No vector, create a default one\n      scalar = defaultValue;\n    } else if (typeof p === 'number' && isFinite(p)) {\n      // Expand single channel to multiple vector\n      scalar = p;\n    }\n\n    var out = [];\n    var i;\n    if (scalar == null) {\n      for (i = 0; i < dims; i++) {\n        out[i] = toFinite(p[i], defaultValue);\n      }\n    } else {\n      for (i = 0; i < dims; i++) {\n        out[i] = scalar;\n      }\n    }\n    return out;\n  };\n}\n\nfunction lerpArray (min, max, t, out) {\n  out = out || [];\n  if (min.length !== max.length) {\n    throw new TypeError('min and max array are expected to have the same length');\n  }\n  for (var i = 0; i < min.length; i++) {\n    out[i] = lerp(min[i], max[i], t);\n  }\n  return out;\n}\n\nfunction newArray (n, initialValue) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  var out = [];\n  for (var i = 0; i < n; i++) out.push(initialValue);\n  return out;\n}\n\nfunction linspace (n, opts) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  opts = opts || {};\n  if (typeof opts === 'boolean') {\n    opts = { endpoint: true };\n  }\n  var offset = defined(opts.offset, 0);\n  if (opts.endpoint) {\n    return newArray(n).map(function (_, i) {\n      return n <= 1 ? 0 : ((i + offset) / (n - 1));\n    });\n  } else {\n    return newArray(n).map(function (_, i) {\n      return (i + offset) / n;\n    });\n  }\n}\n\nfunction lerpFrames (values, t, out) {\n  t = clamp(t, 0, 1);\n\n  var len = values.length - 1;\n  var whole = t * len;\n  var frame = Math.floor(whole);\n  var fract = whole - frame;\n\n  var nextFrame = Math.min(frame + 1, len);\n  var a = values[frame % values.length];\n  var b = values[nextFrame % values.length];\n  if (typeof a === 'number' && typeof b === 'number') {\n    return lerp(a, b, fract);\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return lerpArray(a, b, fract, out);\n  } else {\n    throw new TypeError('Mismatch in value type of two array elements: ' + frame + ' and ' + nextFrame);\n  }\n}\n\nfunction mod (a, b) {\n  return ((a % b) + b) % b;\n}\n\nfunction degToRad (n) {\n  return n * Math.PI / 180;\n}\n\nfunction radToDeg (n) {\n  return n * 180 / Math.PI;\n}\n\nfunction fract (n) {\n  return n - Math.floor(n);\n}\n\nfunction sign (n) {\n  if (n > 0) return 1;\n  else if (n < 0) return -1;\n  else return 0;\n}\n\n// Specific function from Unity / ofMath, not sure its needed?\n// function lerpWrap (a, b, t, min, max) {\n//   return wrap(a + wrap(b - a, min, max) * t, min, max)\n// }\n\nfunction pingPong (t, length) {\n  t = mod(t, length * 2);\n  return length - Math.abs(t - length);\n}\n\nfunction damp (a, b, lambda, dt) {\n  return lerp(a, b, 1 - Math.exp(-lambda * dt));\n}\n\nfunction dampArray (a, b, lambda, dt, out) {\n  out = out || [];\n  for (var i = 0; i < a.length; i++) {\n    out[i] = damp(a[i], b[i], lambda, dt);\n  }\n  return out;\n}\n\nfunction mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {\n  // Reference:\n  // https://openframeworks.cc/documentation/math/ofMath/\n  if (Math.abs(inputMin - inputMax) < EPSILON) {\n    return outputMin;\n  } else {\n    var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);\n    if (clamp) {\n      if (outputMax < outputMin) {\n        if (outVal < outputMax) outVal = outputMax;\n        else if (outVal > outputMin) outVal = outputMin;\n      } else {\n        if (outVal > outputMax) outVal = outputMax;\n        else if (outVal < outputMin) outVal = outputMin;\n      }\n    }\n    return outVal;\n  }\n}\n\nmodule.exports = {\n  mod: mod,\n  fract: fract,\n  sign: sign,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  wrap: wrap,\n  pingPong: pingPong,\n  linspace: linspace,\n  lerp: lerp,\n  lerpArray: lerpArray,\n  inverseLerp: inverseLerp,\n  lerpFrames: lerpFrames,\n  clamp: clamp,\n  clamp01: clamp01,\n  smoothstep: smoothstep,\n  damp: damp,\n  dampArray: dampArray,\n  mapRange: mapRange,\n  expand2D: expandVector(2),\n  expand3D: expandVector(3),\n  expand4D: expandVector(4)\n};\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","import pointInsidePolygon from 'point-in-polygon';\n\n/**\n * Get vectors intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {number[]}\n */\nexport function findIntersection(p1, p2, p3, p4) {\n  const x =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[0] - p4[0]) - (p1[0] - p2[0]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  const y =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  return [x, y];\n}\n\n/**\n * Is point on line\n * @param p\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction isPointBetween(p, a, b) {\n  return (\n    ((a[0] <= p[0] && p[0] <= b[0]) || (a[0] >= p[0] && p[0] >= b[0])) &&\n    ((a[1] <= p[1] && p[1] <= b[1]) || (a[1] >= p[1] && p[1] >= b[1]))\n  );\n}\n\n/**\n * Get segments intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {*}\n */\nexport function findSegmentIntersection(p1, p2, p3, p4) {\n  const i1 = findIntersection(p1, p2, p3, p4);\n\n  const isIntersected = isPointBetween(i1, p1, p2) && isPointBetween(i1, p3, p4);\n  return isIntersected ? i1 : false;\n}\n\n/**\n * Get two points distance\n * @returns {number}\n * @param p1x\n * @param p1y\n * @param p2x\n * @param p2y\n */\nexport function pointsDistance(p1x, p1y, p2x, p2y) {\n  return Math.sqrt((p1x - p2x) ** 2 + (p1y - p2y) ** 2);\n}\n\n/**\n * Length of segment\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns {number}\n */\nexport function lineLength([x1, y1], [x2, y2]) {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n *\n * @param angle (RADIANS)\n * @param distance\n * @param initPoint\n * @returns {number[]}\n */\nexport function getPointCoordsByAngleAndDistance(angle, distance, initPoint = [0, 0]) {\n  const xC = distance * Math.cos(angle);\n  const yC = distance * Math.sin(angle);\n  return [initPoint[0] + xC, initPoint[1] + yC];\n}\n\n/**\n * Determine if circle is fully places in another one\n * @param c1\n * @param c2\n * @param auto - automatic set smaller circle on first place\n * @returns {boolean}\n */\nexport function isCircleInCircle(c1, c2, auto = false) {\n  let x0;\n  let y0;\n  let r0;\n  let x1;\n  let y1;\n  let r1;\n\n  if (!auto || c2.r1 >= c1.r1) {\n    [x0, y0, r0] = c1;\n    [x1, y1, r1] = c2;\n  } else {\n    [x1, y1, r1] = c2;\n    [x0, y0, r0] = c1;\n  }\n\n  return r1 >= Math.hypot(x1 - x0, y1 - y0) + r0;\n}\n\n/**\n * Get two circles intersection\n *\n * Original: https://stackoverflow.com/a/12221389/1531295\n *\n * @param x0\n * @param y0\n * @param r0\n * @param x1\n * @param y1\n * @param r1\n * @param getCoordinates\n */\nexport function twoCirclesIntersection([x0, y0, r0], [x1, y1, r1], getCoordinates = true) {\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  const dx = x1 - x0;\n  const dy = y1 - y0;\n\n  /* Determine the straight-line distance between the centers. */\n  const d = Math.hypot(dy, dx);\n\n  /* Check for solvability. */\n  if (d > r0 + r1) {\n    /* no solution. circles do not intersect. */\n    return false;\n  }\n  if (d < Math.abs(r0 - r1)) {\n    /* no solution. one circle is contained in the other */\n    return false;\n  }\n\n  if (!getCoordinates) {\n    return true;\n  }\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.\n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  const a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);\n\n  /* Determine the coordinates of point 2. */\n  const x2 = x0 + (dx * a) / d;\n  const y2 = y0 + (dy * a) / d;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n  const h = Math.sqrt(r0 * r0 - a * a);\n\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  const rx = -dy * (h / d);\n  const ry = dx * (h / d);\n\n  /* Determine the absolute intersection points. */\n  const xi = x2 + rx;\n  const xiPrime = x2 - rx;\n  const yi = y2 + ry;\n  const yiPrime = y2 - ry;\n\n  return [xi, xiPrime, yi, yiPrime];\n}\n\nexport function circeIntersectWithCircles(circle, anotherCircles) {\n  let intersect = false;\n  for (let i = 0; i < anotherCircles.length; i += 1) {\n    const aCircle = anotherCircles[i];\n    intersect =\n      intersect ||\n      twoCirclesIntersection([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], false) ||\n      isCircleInCircle([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], true);\n    if (intersect) {\n      break;\n    }\n  }\n  return intersect;\n}\n\n/**\n * Check circle is in polygon\n * @param cx\n * @param cy\n * @param cr\n * @param polygon\n * @returns {boolean}\n */\nexport function circleInPolygon([cx, cy, cr], polygon) {\n  // Check center inside first\n  if (!pointInsidePolygon([cx, cy], polygon)) {\n    return false;\n  }\n\n  // Get 7 points of contour and check them\n  for (let angle = -Math.PI * 2; angle < Math.PI; angle += Math.PI / 4) {\n    const xC = cr * Math.cos(angle);\n    const yC = cr * Math.sin(angle);\n\n    const p = [xC + cx, yC + cy];\n\n    if (!pointInsidePolygon(p, polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Make angle in range of [-Math.PI, Math.PI]\n * @param a\n * @returns {number}\n */\nexport function simpleAngle(a) {\n  if (a >= Math.PI * 2) {\n    return a - Math.PI * 2;\n  }\n  if (a < 0) {\n    return a + Math.PI * 2;\n  }\n  return a;\n}\n\n/**\n * Calculate angle of reflect\n * @param incidenceAngle\n * @param surfaceAngle\n * @returns {number}\n */\nexport function angleReflect(incidenceAngle, surfaceAngle) {\n  return simpleAngle(surfaceAngle * 2 - incidenceAngle);\n}\n","module.exports = function vec2Copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    return out\n}","import random from 'canvas-sketch-util/random';\nimport pointInsidePolygon from 'point-in-polygon';\nimport chaikinSmooth from 'chaikin-smooth';\nimport { circeIntersectWithCircles, getPointCoordsByAngleAndDistance } from './geometry';\n\n/**\n * Get rope shape contour coordinates\n * @param coords [[x,y,r]...]\n */\nexport function rope(coords) {\n  const lineContour1 = [];\n  const lineContour2 = [];\n\n  coords.forEach((p, idx) => {\n    let pB;\n    if (idx === 0) {\n      pB = coords[idx + 1];\n    } else {\n      pB = coords[idx - 1];\n    }\n\n    let angle;\n\n    if (idx === 0) {\n      angle = Math.atan2(p[1] - pB[1], p[0] - pB[0]); // radians\n    } else {\n      angle = Math.atan2(pB[1] - p[1], pB[0] - p[0]); // radians\n    }\n\n    [-(Math.PI / 2), -(Math.PI / 2) * 3].forEach((rotate, idx) => {\n      const xC = p[2] * Math.cos(angle + rotate);\n      const yC = p[2] * Math.sin(angle + rotate);\n\n      if (idx % 2) {\n        lineContour1.push([xC + p[0], yC + p[1]]);\n      } else {\n        lineContour2.push([xC + p[0], yC + p[1]]);\n      }\n    });\n  });\n\n  return [...lineContour1, ...lineContour2.reverse()];\n}\n\nexport function smoothPath(path, level = 0) {\n  path = chaikinSmooth(path);\n  if (level === 0) {\n    return path;\n  }\n  return smoothPath(path, level - 1);\n}\n\nexport function circleTree({\n  x = 0,\n  y = 0,\n  r = 0.5,\n  angle = -Math.PI / 2,\n\n  maxTriesFindNewPoint = 3,\n  tension = 2,\n  newBranchTension = 2,\n  maxGenerations = 8,\n  minRadius = 0.005,\n  reduceRadiusFactor = 0.95,\n  maxBends = 100,\n  subTreesFromNode = 5,\n  limitPolygon,\n  reduceRadiusOnFail = false,\n  newPointSearchAngel = Math.PI / 6,\n  newBranchSearchAngel = Math.PI / 3,\n} = {}) {\n  let allPoints = [];\n  const branches = [];\n  const makeBranch = ({ x, y, r, angle }, beforePoint = null, generation = 1) => {\n    if (generation > maxGenerations) {\n      return;\n    }\n\n    let branch = [];\n    for (let i = 0; i < maxBends; i += 1) {\n      if (i === 0) {\n        const point = {\n          x,\n          y,\n          r,\n          isRoot: true,\n          generation,\n        };\n        branch.push(point);\n        allPoints.push(point);\n      } else {\n        const bPoint = branch[i - 1];\n\n        let tries = 0;\n        let foundPoint = false;\n        let point;\n        while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n          tries += 1;\n\n          const rad = random.range(angle - newPointSearchAngel, angle + newPointSearchAngel);\n          const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * tension, [bPoint.x, bPoint.y]);\n          point = {\n            x: coords[0],\n            y: coords[1],\n            r: bPoint.r * reduceRadiusFactor - ((1 - 1 / tries) * bPoint.r) / 5,\n            generation,\n            angle: rad,\n          };\n\n          if (limitPolygon && !pointInsidePolygon([point.x, point.y], limitPolygon)) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // Stop if radius too small\n          if (point.r < minRadius) {\n            break;\n          }\n\n          // eslint-disable-next-line no-loop-func\n          const comparingPoints = allPoints.filter(p => {\n            return p !== branch[branch.length - 1];\n          });\n\n          if (!circeIntersectWithCircles(point, comparingPoints)) {\n            branch.push(point);\n            allPoints.push(point);\n            foundPoint = true;\n          }\n        }\n\n        // If could not find optimal position - stop\n        if (!foundPoint) {\n          break;\n        }\n\n        // From N-th node create sub branches\n        if (i > subTreesFromNode) {\n          tries = 0;\n          foundPoint = false;\n          while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n            tries += 1;\n\n            const rad = random.range(angle - newBranchSearchAngel, angle + newBranchSearchAngel);\n            const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * newBranchTension, [bPoint.x, bPoint.y]);\n            point = {\n              x: coords[0],\n              y: coords[1],\n              r: bPoint.r * reduceRadiusFactor - (reduceRadiusOnFail ? ((1 - 1 / tries) * bPoint.r) / 2 : 0),\n            };\n\n            // eslint-disable-next-line no-loop-func\n            const comparingPoints = allPoints.filter(p => {\n              return p !== branch[branch.length - 1] && p !== branch[branch.length - 2];\n            });\n\n            if (!circeIntersectWithCircles(point, comparingPoints)) {\n              foundPoint = true;\n              makeBranch(\n                { ...point, r: point.r / 1, angle: rad },\n                { ...branch[branch.length - 2], generation: generation + 1 },\n                generation + 1,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (branch.length > 1) {\n      if (beforePoint) {\n        branch = [beforePoint, ...branch];\n      }\n      branches.push(branch);\n    } else {\n      allPoints = allPoints.slice(0, -1);\n    }\n  };\n\n  makeBranch({\n    x,\n    y,\n    r,\n    angle,\n  });\n\n  return branches;\n}\n","var copy = require('vec2-copy')\n\nmodule.exports = function(input, output) {\n    if (!Array.isArray(output))\n        output = []\n\n    if (input.length>0)\n        output.push(copy([0, 0], input[0]))\n    for (var i=0; i<input.length-1; i++) {\n        var p0 = input[i]\n        var p1 = input[i+1]\n        var p0x = p0[0],\n            p0y = p0[1],\n            p1x = p1[0],\n            p1y = p1[1]\n\n        var Q = [ 0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y ]\n        var R = [ 0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y ]\n        output.push(Q)\n        output.push(R)\n    }\n    if (input.length > 1)\n        output.push(copy([0, 0], input[ input.length-1 ]))\n    return output\n}","import random from 'canvas-sketch-util/random';\nimport { lerp } from 'canvas-sketch-util/math';\nimport { circleTree, rope } from '@/utils/shape';\n\nconst seed = random.getRandomSeed();\nrandom.setSeed(seed);\n\nconst settings = {\n  dimensions: [1024, 1024],\n  animate: true,\n};\n\nconst sketch = async ({ width, height }) => {\n  const margin = width * 0.1;\n\n  const sx = v => lerp(margin, width - margin, v);\n  const sy = v => lerp(margin, height - margin, v);\n\n  let prevTime = -10;\n\n  return ({ context, width, height, time, playhead }) => {\n    if (time - prevTime < 2) {\n      return;\n    }\n    prevTime = time;\n\n    const tree = circleTree({\n      x: 0.5,\n      y: 1,\n      r: 0.025,\n      angle: -Math.PI / 2,\n      tension: 1.8,\n      newBranchTension: 1.5,\n      limitPolygon: [\n        [0, 0],\n        [1, 0],\n        [1, 1],\n        [0, 1],\n      ],\n      maxGenerations: 40,\n      reduceRadiusFactor: 0.98,\n      maxBends: 10,\n      maxTriesFindNewPoint: 3,\n      subTreesFromNode: 3,\n      reduceRadiusOnFail: false,\n    });\n\n    context.fillStyle = 'hsl(0, 0%, 98%)';\n    context.fillRect(0, 0, width, height);\n\n    context.strokeStyle = 'hsl(0, 0%, 20%)';\n\n    tree.forEach((branch, branchIdx) => {\n      const branchCoords = branch.map(p => [p.x, p.y, p.r]);\n\n      branchCoords[branchCoords.length - 1][2] = 0.0;\n\n      const ropeCoords = rope(branchCoords, branch);\n\n      if (branch[0].generation === 1) {\n        ropeCoords[0][1] = 1;\n        ropeCoords[ropeCoords.length - 1][1] = 1;\n      }\n\n      context.fillStyle = `hsl(${branch[0].generation * 20}, 50%, 70%)`;\n\n      context.beginPath();\n      ropeCoords.forEach(([x, y], idx) => {\n        if (idx === 0) {\n          context.moveTo(sx(x), sy(y));\n        } else {\n          context.lineTo(sx(x), sy(y));\n        }\n      });\n      context.closePath();\n      context.fill();\n    });\n\n    context.fillStyle = 'hsl(0, 80%, 50%)';\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}