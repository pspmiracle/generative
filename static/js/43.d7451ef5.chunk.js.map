{"version":3,"sources":["sketches/028_particles_sphere_2/shaders/vert.glsl","sketches/028_particles_sphere_2/shaders/frag.glsl","sketches/028_particles_sphere_2/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","Black","camera","Math","PI","Zero","attachControl","fov","allowUpsideDown","norotationconstraint","lowerBetaLimit","upperBetaLimit","lowerRadiusLimit","upperRadiusLimit","ShadersStore","customVertexShader","customFragmentShader","sphere","CreateIcoSphere","radius","subdivisions","pcs","updatable","addSurfacePoints","White","pMaterial","vertex","fragment","attributes","uniforms","needAlphaBlending","pointsCloud","alphaMode","ALPHA_ADD","backFaceCulling","setFloat","buildMeshAsync","then","mesh","material","dispose","render","time","alpha","aRatio","getEngine","getAspectRatio","setVector2","resize","pixelRatio","unload","settings","animate","context"],"mappings":"iHAAA,OAAe,05N,iCCAf,OAAe,mmH,+FCSTA,EAAM,uCAAG,yCAAAC,EAAA,6DAASC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAGLC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAaJ,SAAeK,OAC5BC,EAAS,IAAIN,kBAAwB,UAAWO,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAG,KAAMR,UAAgBS,OAAQN,IACvGO,cAAcd,GAAQ,GAC7BU,EAAOK,IAAM,EACbL,EAAOM,iBAAkB,EACzBN,EAAOO,sBAAuB,EAC9BP,EAAOQ,eAAiB,KACxBR,EAAOS,eAAiB,KAExBT,EAAOU,iBAAmB,KAC1BV,EAAOW,iBAAmB,KAI1BjB,SAAekB,aAAaC,mBAAqBA,UACjDnB,SAAekB,aAAaE,qBAAuBA,UAE7CC,EAAS,IAAIrB,cAAoBsB,gBAAgB,SAAU,CAAEC,OAAQ,EAAGC,aAAc,GAAKrB,IAE3FsB,EAAM,IAAIzB,oBAA0B,MAAO,EAAGG,EAAO,CAAEuB,WAAW,KACpEC,iBAAiBN,EAAQ,IAAQrB,SAAe4B,QAE9CC,EAAY,IAAI7B,iBACpB,SACAG,EACA,CACE2B,OAAQ,SACRC,SAAU,UAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,cAAe,SACxFC,mBAAmB,KAGbC,aAAc,EAExBN,EAAUO,UAAYpC,SAAeqC,UACrCR,EAAUS,iBAAkB,EAE5BT,EAAUU,SAAS,cAAe,IAAIvC,UAAgB,EAAG,IACzD6B,EAAUU,SAAS,QAAS,GAE5Bd,EAAIe,iBAAiBC,MAAK,SAAAC,GACxBjB,EAAIiB,KAAKC,SAAWd,EACpBR,EAAOuB,aApDI,kBAuDN,CACLC,OADK,YACa,IAATC,EAAQ,EAARA,KACPxC,EAAOyC,OAAS,OAChBlB,EAAUU,SAAS,QAASO,GAC5B,IAAME,EAAS7C,EAAM8C,YAAYC,eAAe5C,GAChDuB,EAAUsB,WAAW,cAAe,IAAInD,UAAgBgD,EAAQ,IAEhE7C,EAAM0C,UAERO,OATK,YASiC,EAA7BC,WAA6B,EAAjBxD,MAAiB,EAAVC,OAC1BC,EAAOqD,UAETE,OAZK,WAaHvD,EAAO6C,aApEE,4CAAH,sDAyEG,WAAElD,SAAQ6D,SA9ER,CACfC,SAAS,EACTC,QAAS","file":"static/js/43.d7451ef5.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nvarying vec2 vUv;\\nvarying vec3 opos;\\nvarying vec3 vpos;\\nvarying float size;\\n\\nuniform float iTime;\\nuniform float pSize;\\n\\nuniform mat4 worldViewProjection;\\nuniform mat4 world;\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_0(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_0(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_0(vec4 x) {\\n     return mod289_0(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_0(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289_0(i);\\n  vec4 p = permute_0( permute_0( permute_0(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt_0(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\n//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289_1(vec3 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289_1(vec4 x)\\n{\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute_1(vec4 x)\\n{\\n  return mod289_1(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt_1(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec3 fade(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n  Pi0 = mod289_1(Pi0);\\n  Pi1 = mod289_1(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute_1(permute_1(ix) + iy);\\n  vec4 ixy0 = permute_1(ixy + iz0);\\n  vec4 ixy1 = permute_1(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt_1(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt_1(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\\n  return 2.2 * n_xyz;\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n  float t = iTime*.1;\\n\\n  opos = position;\\n  vpos = position;\\n\\n  vec3 chTime = vec3(t);\\n  vpos.xyz *= 1. + snoise(position*1.5 + chTime)*.15;\\n  vpos.xyz *= 1. + snoise(position*5.5 + chTime)*.075;\\n  vpos.xyz *= 1. + snoise(position*10.5 + chTime*5.)*.025;\\n\\n  float rFactor = fract(snoise(opos*100.)) > .5 ? 1.1 : 1.;\\n\\n  size = pSize;\\n  gl_PointSize = pSize + (length(vpos)-.75)*10.;\\n\\n  gl_Position = worldViewProjection * vec4( vpos*rFactor, 1.0 );\\n}\\n\";","export default \"#define GLSLIFY 1\\nvarying vec3 vpos;\\nvarying vec3 opos;\\nvarying float size;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\n\\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g_0 = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g_0;\\n  vec3 i1 = min( g_0.xyz, l.zxy );\\n  vec3 i2 = max( g_0.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\\n  vec2 uv = (vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  float alpha = .01/smoothstep(.0, 5., length(uv)*5.);\\n\\n  float g = length(uv);\\n  float gcl = 1. - length(uv)/size;\\n\\n  float t = iTime*.2;\\n  float vposFactor = snoise(opos*2.);\\n  fragColor = vec4(hue(fract(length(vpos)*size*.25 + t + vposFactor)).rgb, alpha);\\n}\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport customVertexShader from './shaders/vert.glsl';\nimport customFragmentShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = BABYLON.Color3.Black;\n  const camera = new BABYLON.ArcRotateCamera('Camera', -Math.PI / 2, Math.PI / 2, 2.25, BABYLON.Vector3.Zero(), scene);\n  camera.attachControl(canvas, true);\n  camera.fov = 5.0;\n  camera.allowUpsideDown = true;\n  camera.norotationconstraint = true;\n  camera.lowerBetaLimit = null;\n  camera.upperBetaLimit = null;\n\n  camera.lowerRadiusLimit = 2.25;\n  camera.upperRadiusLimit = 2.25;\n\n\n\n  BABYLON.Effect.ShadersStore.customVertexShader = customVertexShader;\n  BABYLON.Effect.ShadersStore.customFragmentShader = customFragmentShader;\n\n  const sphere = new BABYLON.MeshBuilder.CreateIcoSphere('sphere', { radius: 1, subdivisions: 5 }, scene);\n\n  const pcs = new BABYLON.PointsCloudSystem('pcs', 0, scene, { updatable: false });\n  pcs.addSurfacePoints(sphere, 100000, BABYLON.Color3.White);\n\n  const pMaterial = new BABYLON.ShaderMaterial(\n    'shader',\n    scene,\n    {\n      vertex: 'custom',\n      fragment: 'custom',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'iTime', 'iResolution', 'pSize'],\n      needAlphaBlending: true,\n    },\n  );\n  pMaterial.pointsCloud = true;\n\n  pMaterial.alphaMode = BABYLON.Engine.ALPHA_ADD;\n  pMaterial.backFaceCulling = false;\n\n  pMaterial.setFloat('iResolution', new BABYLON.Vector2(1, 1));\n  pMaterial.setFloat('pSize', 5);\n\n  pcs.buildMeshAsync().then(mesh => {\n    pcs.mesh.material = pMaterial;\n    sphere.dispose();\n  });\n\n  return {\n    render({ time }) {\n      camera.alpha += 0.00125;\n      pMaterial.setFloat('iTime', time);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      pMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}