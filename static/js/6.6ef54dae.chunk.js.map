{"version":3,"sources":["../node_modules/canvas-sketch-util/lib/wrap.js","../node_modules/canvas-sketch-util/math.js","../node_modules/point-in-polygon/index.js","utils/ctx.js","utils/geometry.js","../node_modules/vec2-copy/index.js","utils/shape.js","../node_modules/chaikin-smooth/index.js","utils/collection.js","sketches/007_lines_rain/index.js"],"names":["module","exports","value","from","to","TypeError","t","cycle","Math","floor","defined","require","wrap","EPSILON","Number","clamp","min","max","lerp","inverseLerp","abs","toFinite","n","defaultValue","isFinite","expandVector","dims","p","scalar","i","out","lerpArray","length","newArray","initialValue","push","mod","a","b","damp","lambda","dt","exp","fract","sign","degToRad","PI","radToDeg","pingPong","linspace","opts","endpoint","offset","map","_","lerpFrames","values","len","whole","frame","nextFrame","Array","isArray","clamp01","v","smoothstep","x","dampArray","mapRange","inputMin","inputMax","outputMin","outputMax","outVal","expand2D","expand3D","expand4D","point","vs","y","inside","j","xi","yi","xj","yj","setDrawPolygon","context","lineCoords","closePath","beginPath","moveTo","lineTo","drawLine","stroke","isPointBetween","findSegmentIntersection","p1","p2","p3","p4","i1","findIntersection","pointsDistance","p1x","p1y","p2x","p2y","sqrt","getPointCoordsByAngleAndDistance","angle","distance","initPoint","xC","cos","yC","sin","isCircleInCircle","c1","c2","x0","y0","r0","x1","y1","r1","auto","hypot","twoCirclesIntersection","getCoordinates","dx","dy","d","x2","y2","h","rx","ry","xiPrime","yiPrime","circeIntersectWithCircles","circle","anotherCircles","intersect","aCircle","r","rope","coords","lineContour1","lineContour2","forEach","idx","pB","atan2","rotate","reverse","smoothPath","path","level","chaikinSmooth","circleTree","maxTriesFindNewPoint","tension","newBranchTension","maxGenerations","minRadius","reduceRadiusFactor","maxBends","subTreesFromNode","limitPolygon","reduceRadiusOnFail","newPointSearchAngel","newBranchSearchAngel","allPoints","branches","makeBranch","beforePoint","generation","branch","isRoot","bPoint","tries","foundPoint","rad","random","range","pointInsidePolygon","comparingPoints","filter","slice","copy","input","output","p0","p0x","p0y","Q","R","Collection","this","items","item","add","remove","Symbol","iterator","sketch","canvas","width","height","lines","palette","speedRange","sizeRange","thicknessRange","fromY","circles","addEventListener","e","rect","target","getBoundingClientRect","kX","kY","clientX","left","clientY","top","deltaY","cleanLines","line","inScreen","points","rampUpLine","speed","allCircles","distanceDiff","diffX","diffY","prevY","size","createLine","rangeFloor","color","pick","thickness","fillStyle","fillRect","strokeStyle","arc","ropeCoords","settings","dimensions","orientation","animate"],"mappings":"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","file":"static/js/6.6ef54dae.chunk.js","sourcesContent":["module.exports = wrap;\nfunction wrap (value, from, to) {\n  if (typeof from !== 'number' || typeof to !== 'number') {\n    throw new TypeError('Must specify \"to\" and \"from\" arguments as numbers');\n  }\n  // algorithm from http://stackoverflow.com/a/5852628/599884\n  if (from > to) {\n    var t = from;\n    from = to;\n    to = t;\n  }\n  var cycle = to - from;\n  if (cycle === 0) {\n    return to;\n  }\n  return value - cycle * Math.floor((value - from) / cycle);\n}\n","var defined = require('defined');\nvar wrap = require('./lib/wrap');\nvar EPSILON = Number.EPSILON;\n\nfunction clamp (value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value);\n}\n\nfunction clamp01 (v) {\n  return clamp(v, 0, 1);\n}\n\nfunction lerp (min, max, t) {\n  return min * (1 - t) + max * t;\n}\n\nfunction inverseLerp (min, max, t) {\n  if (Math.abs(min - max) < EPSILON) return 0;\n  else return (t - min) / (max - min);\n}\n\nfunction smoothstep (min, max, t) {\n  var x = clamp(inverseLerp(min, max, t), 0, 1);\n  return x * x * (3 - 2 * x);\n}\n\nfunction toFinite (n, defaultValue) {\n  defaultValue = defined(defaultValue, 0);\n  return typeof n === 'number' && isFinite(n) ? n : defaultValue;\n}\n\nfunction expandVector (dims) {\n  if (typeof dims !== 'number') throw new TypeError('Expected dims argument');\n  return function (p, defaultValue) {\n    defaultValue = defined(defaultValue, 0);\n    var scalar;\n    if (p == null) {\n      // No vector, create a default one\n      scalar = defaultValue;\n    } else if (typeof p === 'number' && isFinite(p)) {\n      // Expand single channel to multiple vector\n      scalar = p;\n    }\n\n    var out = [];\n    var i;\n    if (scalar == null) {\n      for (i = 0; i < dims; i++) {\n        out[i] = toFinite(p[i], defaultValue);\n      }\n    } else {\n      for (i = 0; i < dims; i++) {\n        out[i] = scalar;\n      }\n    }\n    return out;\n  };\n}\n\nfunction lerpArray (min, max, t, out) {\n  out = out || [];\n  if (min.length !== max.length) {\n    throw new TypeError('min and max array are expected to have the same length');\n  }\n  for (var i = 0; i < min.length; i++) {\n    out[i] = lerp(min[i], max[i], t);\n  }\n  return out;\n}\n\nfunction newArray (n, initialValue) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  var out = [];\n  for (var i = 0; i < n; i++) out.push(initialValue);\n  return out;\n}\n\nfunction linspace (n, opts) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  opts = opts || {};\n  if (typeof opts === 'boolean') {\n    opts = { endpoint: true };\n  }\n  var offset = defined(opts.offset, 0);\n  if (opts.endpoint) {\n    return newArray(n).map(function (_, i) {\n      return n <= 1 ? 0 : ((i + offset) / (n - 1));\n    });\n  } else {\n    return newArray(n).map(function (_, i) {\n      return (i + offset) / n;\n    });\n  }\n}\n\nfunction lerpFrames (values, t, out) {\n  t = clamp(t, 0, 1);\n\n  var len = values.length - 1;\n  var whole = t * len;\n  var frame = Math.floor(whole);\n  var fract = whole - frame;\n\n  var nextFrame = Math.min(frame + 1, len);\n  var a = values[frame % values.length];\n  var b = values[nextFrame % values.length];\n  if (typeof a === 'number' && typeof b === 'number') {\n    return lerp(a, b, fract);\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return lerpArray(a, b, fract, out);\n  } else {\n    throw new TypeError('Mismatch in value type of two array elements: ' + frame + ' and ' + nextFrame);\n  }\n}\n\nfunction mod (a, b) {\n  return ((a % b) + b) % b;\n}\n\nfunction degToRad (n) {\n  return n * Math.PI / 180;\n}\n\nfunction radToDeg (n) {\n  return n * 180 / Math.PI;\n}\n\nfunction fract (n) {\n  return n - Math.floor(n);\n}\n\nfunction sign (n) {\n  if (n > 0) return 1;\n  else if (n < 0) return -1;\n  else return 0;\n}\n\n// Specific function from Unity / ofMath, not sure its needed?\n// function lerpWrap (a, b, t, min, max) {\n//   return wrap(a + wrap(b - a, min, max) * t, min, max)\n// }\n\nfunction pingPong (t, length) {\n  t = mod(t, length * 2);\n  return length - Math.abs(t - length);\n}\n\nfunction damp (a, b, lambda, dt) {\n  return lerp(a, b, 1 - Math.exp(-lambda * dt));\n}\n\nfunction dampArray (a, b, lambda, dt, out) {\n  out = out || [];\n  for (var i = 0; i < a.length; i++) {\n    out[i] = damp(a[i], b[i], lambda, dt);\n  }\n  return out;\n}\n\nfunction mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {\n  // Reference:\n  // https://openframeworks.cc/documentation/math/ofMath/\n  if (Math.abs(inputMin - inputMax) < EPSILON) {\n    return outputMin;\n  } else {\n    var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);\n    if (clamp) {\n      if (outputMax < outputMin) {\n        if (outVal < outputMax) outVal = outputMax;\n        else if (outVal > outputMin) outVal = outputMin;\n      } else {\n        if (outVal > outputMax) outVal = outputMax;\n        else if (outVal < outputMin) outVal = outputMin;\n      }\n    }\n    return outVal;\n  }\n}\n\nmodule.exports = {\n  mod: mod,\n  fract: fract,\n  sign: sign,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  wrap: wrap,\n  pingPong: pingPong,\n  linspace: linspace,\n  lerp: lerp,\n  lerpArray: lerpArray,\n  inverseLerp: inverseLerp,\n  lerpFrames: lerpFrames,\n  clamp: clamp,\n  clamp01: clamp01,\n  smoothstep: smoothstep,\n  damp: damp,\n  dampArray: dampArray,\n  mapRange: mapRange,\n  expand2D: expandVector(2),\n  expand3D: expandVector(3),\n  expand4D: expandVector(4)\n};\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","export function setDrawPolygon(context, lineCoords, closePath = false) {\n  context.beginPath();\n  for (let i = 0; i < lineCoords.length; i += 1) {\n    const p = lineCoords[i];\n    if (i === 0) {\n      context.moveTo(p[0], p[1]);\n    } else {\n      context.lineTo(p[0], p[1]);\n    }\n  }\n  if (closePath) {\n    context.closePath();\n  }\n}\n\nexport const drawLine = (context, lineCoords, closePath = false) => {\n  setDrawPolygon(context, lineCoords, closePath);\n  context.stroke();\n};\n\nexport function setPixel(imgData, x, y, cR, cG, cB, cA = 255) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  imgData.data[n] = ~~cR;\n  imgData.data[n + 1] = ~~cG;\n  imgData.data[n + 2] = ~~cB;\n  imgData.data[n + 3] = ~~cA;\n}\n\nconst resultGetPixelArray = [0, 0, 0, 0];\nexport function getPixel(imgData, x, y, colorNumber) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  if (colorNumber !== undefined) {\n    return imgData.data[n + colorNumber];\n  }\n\n  for (let i = 0; i < 4; i += 1) {\n    resultGetPixelArray[i] = n + i;\n  }\n  return resultGetPixelArray;\n}\n","import pointInsidePolygon from 'point-in-polygon';\n\n/**\n * Get vectors intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {number[]}\n */\nexport function findIntersection(p1, p2, p3, p4) {\n  const x =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[0] - p4[0]) - (p1[0] - p2[0]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  const y =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  return [x, y];\n}\n\n/**\n * Is point on line\n * @param p\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction isPointBetween(p, a, b) {\n  return (\n    ((a[0] <= p[0] && p[0] <= b[0]) || (a[0] >= p[0] && p[0] >= b[0])) &&\n    ((a[1] <= p[1] && p[1] <= b[1]) || (a[1] >= p[1] && p[1] >= b[1]))\n  );\n}\n\n/**\n * Get segments intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {*}\n */\nexport function findSegmentIntersection(p1, p2, p3, p4) {\n  const i1 = findIntersection(p1, p2, p3, p4);\n\n  const isIntersected = isPointBetween(i1, p1, p2) && isPointBetween(i1, p3, p4);\n  return isIntersected ? i1 : false;\n}\n\n/**\n * Get two points distance\n * @returns {number}\n * @param p1x\n * @param p1y\n * @param p2x\n * @param p2y\n */\nexport function pointsDistance(p1x, p1y, p2x, p2y) {\n  return Math.sqrt((p1x - p2x) ** 2 + (p1y - p2y) ** 2);\n}\n\n/**\n * Length of segment\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns {number}\n */\nexport function lineLength([x1, y1], [x2, y2]) {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n *\n * @param angle (RADIANS)\n * @param distance\n * @param initPoint\n * @returns {number[]}\n */\nexport function getPointCoordsByAngleAndDistance(angle, distance, initPoint = [0, 0]) {\n  const xC = distance * Math.cos(angle);\n  const yC = distance * Math.sin(angle);\n  return [initPoint[0] + xC, initPoint[1] + yC];\n}\n\n/**\n * Determine if circle is fully places in another one\n * @param c1\n * @param c2\n * @param auto - automatic set smaller circle on first place\n * @returns {boolean}\n */\nexport function isCircleInCircle(c1, c2, auto = false) {\n  let x0;\n  let y0;\n  let r0;\n  let x1;\n  let y1;\n  let r1;\n\n  if (!auto || c2.r1 >= c1.r1) {\n    [x0, y0, r0] = c1;\n    [x1, y1, r1] = c2;\n  } else {\n    [x1, y1, r1] = c2;\n    [x0, y0, r0] = c1;\n  }\n\n  return r1 >= Math.hypot(x1 - x0, y1 - y0) + r0;\n}\n\n/**\n * Get two circles intersection\n *\n * Original: https://stackoverflow.com/a/12221389/1531295\n *\n * @param x0\n * @param y0\n * @param r0\n * @param x1\n * @param y1\n * @param r1\n * @param getCoordinates\n */\nexport function twoCirclesIntersection([x0, y0, r0], [x1, y1, r1], getCoordinates = true) {\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  const dx = x1 - x0;\n  const dy = y1 - y0;\n\n  /* Determine the straight-line distance between the centers. */\n  const d = Math.hypot(dy, dx);\n\n  /* Check for solvability. */\n  if (d > r0 + r1) {\n    /* no solution. circles do not intersect. */\n    return false;\n  }\n  if (d < Math.abs(r0 - r1)) {\n    /* no solution. one circle is contained in the other */\n    return false;\n  }\n\n  if (!getCoordinates) {\n    return true;\n  }\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.\n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  const a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);\n\n  /* Determine the coordinates of point 2. */\n  const x2 = x0 + (dx * a) / d;\n  const y2 = y0 + (dy * a) / d;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n  const h = Math.sqrt(r0 * r0 - a * a);\n\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  const rx = -dy * (h / d);\n  const ry = dx * (h / d);\n\n  /* Determine the absolute intersection points. */\n  const xi = x2 + rx;\n  const xiPrime = x2 - rx;\n  const yi = y2 + ry;\n  const yiPrime = y2 - ry;\n\n  return [xi, xiPrime, yi, yiPrime];\n}\n\nexport function circeIntersectWithCircles(circle, anotherCircles) {\n  let intersect = false;\n  for (let i = 0; i < anotherCircles.length; i += 1) {\n    const aCircle = anotherCircles[i];\n    intersect =\n      intersect ||\n      twoCirclesIntersection([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], false) ||\n      isCircleInCircle([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], true);\n    if (intersect) {\n      break;\n    }\n  }\n  return intersect;\n}\n\n/**\n * Check circle is in polygon\n * @param cx\n * @param cy\n * @param cr\n * @param polygon\n * @returns {boolean}\n */\nexport function circleInPolygon([cx, cy, cr], polygon) {\n  // Check center inside first\n  if (!pointInsidePolygon([cx, cy], polygon)) {\n    return false;\n  }\n\n  // Get 7 points of contour and check them\n  for (let angle = -Math.PI * 2; angle < Math.PI; angle += Math.PI / 4) {\n    const xC = cr * Math.cos(angle);\n    const yC = cr * Math.sin(angle);\n\n    const p = [xC + cx, yC + cy];\n\n    if (!pointInsidePolygon(p, polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Make angle in range of [-Math.PI, Math.PI]\n * @param a\n * @returns {number}\n */\nexport function simpleAngle(a) {\n  if (a >= Math.PI * 2) {\n    return a - Math.PI * 2;\n  }\n  if (a < 0) {\n    return a + Math.PI * 2;\n  }\n  return a;\n}\n\n/**\n * Calculate angle of reflect\n * @param incidenceAngle\n * @param surfaceAngle\n * @returns {number}\n */\nexport function angleReflect(incidenceAngle, surfaceAngle) {\n  return simpleAngle(surfaceAngle * 2 - incidenceAngle);\n}\n","module.exports = function vec2Copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    return out\n}","import random from 'canvas-sketch-util/random';\nimport pointInsidePolygon from 'point-in-polygon';\nimport chaikinSmooth from 'chaikin-smooth';\nimport { circeIntersectWithCircles, getPointCoordsByAngleAndDistance } from './geometry';\n\n/**\n * Get rope shape contour coordinates\n * @param coords [[x,y,r]...]\n */\nexport function rope(coords) {\n  const lineContour1 = [];\n  const lineContour2 = [];\n\n  coords.forEach((p, idx) => {\n    let pB;\n    if (idx === 0) {\n      pB = coords[idx + 1];\n    } else {\n      pB = coords[idx - 1];\n    }\n\n    let angle;\n\n    if (idx === 0) {\n      angle = Math.atan2(p[1] - pB[1], p[0] - pB[0]); // radians\n    } else {\n      angle = Math.atan2(pB[1] - p[1], pB[0] - p[0]); // radians\n    }\n\n    [-(Math.PI / 2), -(Math.PI / 2) * 3].forEach((rotate, idx) => {\n      const xC = p[2] * Math.cos(angle + rotate);\n      const yC = p[2] * Math.sin(angle + rotate);\n\n      if (idx % 2) {\n        lineContour1.push([xC + p[0], yC + p[1]]);\n      } else {\n        lineContour2.push([xC + p[0], yC + p[1]]);\n      }\n    });\n  });\n\n  return [...lineContour1, ...lineContour2.reverse()];\n}\n\nexport function smoothPath(path, level = 0) {\n  path = chaikinSmooth(path);\n  if (level === 0) {\n    return path;\n  }\n  return smoothPath(path, level - 1);\n}\n\nexport function circleTree({\n  x = 0,\n  y = 0,\n  r = 0.5,\n  angle = -Math.PI / 2,\n\n  maxTriesFindNewPoint = 3,\n  tension = 2,\n  newBranchTension = 2,\n  maxGenerations = 8,\n  minRadius = 0.005,\n  reduceRadiusFactor = 0.95,\n  maxBends = 100,\n  subTreesFromNode = 5,\n  limitPolygon,\n  reduceRadiusOnFail = false,\n  newPointSearchAngel = Math.PI / 6,\n  newBranchSearchAngel = Math.PI / 3,\n} = {}) {\n  let allPoints = [];\n  const branches = [];\n  const makeBranch = ({ x, y, r, angle }, beforePoint = null, generation = 1) => {\n    if (generation > maxGenerations) {\n      return;\n    }\n\n    let branch = [];\n    for (let i = 0; i < maxBends; i += 1) {\n      if (i === 0) {\n        const point = {\n          x,\n          y,\n          r,\n          isRoot: true,\n          generation,\n        };\n        branch.push(point);\n        allPoints.push(point);\n      } else {\n        const bPoint = branch[i - 1];\n\n        let tries = 0;\n        let foundPoint = false;\n        let point;\n        while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n          tries += 1;\n\n          const rad = random.range(angle - newPointSearchAngel, angle + newPointSearchAngel);\n          const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * tension, [bPoint.x, bPoint.y]);\n          point = {\n            x: coords[0],\n            y: coords[1],\n            r: bPoint.r * reduceRadiusFactor - ((1 - 1 / tries) * bPoint.r) / 5,\n            generation,\n            angle: rad,\n          };\n\n          if (limitPolygon && !pointInsidePolygon([point.x, point.y], limitPolygon)) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // Stop if radius too small\n          if (point.r < minRadius) {\n            break;\n          }\n\n          // eslint-disable-next-line no-loop-func\n          const comparingPoints = allPoints.filter(p => {\n            return p !== branch[branch.length - 1];\n          });\n\n          if (!circeIntersectWithCircles(point, comparingPoints)) {\n            branch.push(point);\n            allPoints.push(point);\n            foundPoint = true;\n          }\n        }\n\n        // If could not find optimal position - stop\n        if (!foundPoint) {\n          break;\n        }\n\n        // From N-th node create sub branches\n        if (i > subTreesFromNode) {\n          tries = 0;\n          foundPoint = false;\n          while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n            tries += 1;\n\n            const rad = random.range(angle - newBranchSearchAngel, angle + newBranchSearchAngel);\n            const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * newBranchTension, [bPoint.x, bPoint.y]);\n            point = {\n              x: coords[0],\n              y: coords[1],\n              r: bPoint.r * reduceRadiusFactor - (reduceRadiusOnFail ? ((1 - 1 / tries) * bPoint.r) / 2 : 0),\n            };\n\n            // eslint-disable-next-line no-loop-func\n            const comparingPoints = allPoints.filter(p => {\n              return p !== branch[branch.length - 1] && p !== branch[branch.length - 2];\n            });\n\n            if (!circeIntersectWithCircles(point, comparingPoints)) {\n              foundPoint = true;\n              makeBranch(\n                { ...point, r: point.r / 1, angle: rad },\n                { ...branch[branch.length - 2], generation: generation + 1 },\n                generation + 1,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (branch.length > 1) {\n      if (beforePoint) {\n        branch = [beforePoint, ...branch];\n      }\n      branches.push(branch);\n    } else {\n      allPoints = allPoints.slice(0, -1);\n    }\n  };\n\n  makeBranch({\n    x,\n    y,\n    r,\n    angle,\n  });\n\n  return branches;\n}\n","var copy = require('vec2-copy')\n\nmodule.exports = function(input, output) {\n    if (!Array.isArray(output))\n        output = []\n\n    if (input.length>0)\n        output.push(copy([0, 0], input[0]))\n    for (var i=0; i<input.length-1; i++) {\n        var p0 = input[i]\n        var p1 = input[i+1]\n        var p0x = p0[0],\n            p0y = p0[1],\n            p1x = p1[0],\n            p1y = p1[1]\n\n        var Q = [ 0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y ]\n        var R = [ 0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y ]\n        output.push(Q)\n        output.push(R)\n    }\n    if (input.length > 1)\n        output.push(copy([0, 0], input[ input.length-1 ]))\n    return output\n}","class Collection {\n  constructor() {\n    this.items = [];\n  }\n\n  /**\n   * Add item to collection\n   * @param item\n   */\n  add(item) {\n    this.items.push(item);\n  }\n\n  /**\n   * Add alias\n   * @param args\n   */\n  append(...args) {\n    this.add(...args);\n  }\n\n  /**\n   * Remove item from collection\n   * @param item\n   */\n  remove(item) {\n    this.items = this.items.filter(i => i !== item);\n  }\n\n  /**\n   * Remove alias\n   * @param args\n   */\n  delete(...args) {\n    this.remove(...args);\n  }\n\n  /**\n   * Remove all items\n   */\n  clean() {\n    this.items = [];\n  }\n\n  get size() {\n    return this.items.length;\n  }\n\n  [Symbol.iterator]() {\n    return this.items.values();\n  }\n}\n\nexport default Collection;\n","import random from 'canvas-sketch-util/random';\nimport { mapRange } from 'canvas-sketch-util/math';\nimport Collection from '@/utils/collection';\nimport { drawLine } from '@/utils/ctx';\nimport { rope } from '@/utils/shape';\n\nconst settings = {\n  dimensions: 'A3',\n  orientation: 'landscape',\n  animate: true,\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const lines = new Collection();\n  const palette = ['#594f4f', '#547980', '#45ada8', '#9de0ad', '#e5fcc2'];\n\n  const speedRange = [5, 20];\n  const sizeRange = [5, 20];\n  const thicknessRange = [0.5, 3];\n\n  const fromY = -height;\n  const toY = 0;\n  const maxLines = 1000;\n\n  const circle = {\n    x: width / 2,\n    y: height / 2,\n    r: 150,\n  };\n  const circles = [];\n\n  canvas.addEventListener('mousemove', e => {\n    const rect = e.target.getBoundingClientRect();\n    const kX = rect.width / width;\n    const kY = rect.height / height;\n    circle.x = Math.floor((e.clientX - rect.left) / kX);\n    circle.y = Math.floor((e.clientY - rect.top) / kY);\n  });\n\n  canvas.addEventListener('mouseleave', () => {\n    circle.x = -9000;\n    circle.y = 0;\n  });\n  canvas.addEventListener('mousewheel', ({ deltaY }) => {\n    if (deltaY > 0) {\n      circle.r = Math.max(circle.r - 10, 20);\n    } else if (deltaY < 0) {\n      circle.r = Math.min(circle.r + 10, width / 2);\n    }\n  });\n\n  canvas.addEventListener('click', () => {\n    circles.push({ ...circle });\n  });\n\n  const cleanLines = () => {\n    for (const line of lines) {\n      let inScreen = false;\n\n      for (const p of line.points) {\n        if (p.x > 0 && p.x < width && p.y > fromY && p.y < height) {\n          inScreen = true;\n        }\n        if (inScreen) {\n          break;\n        }\n      }\n\n      if (!inScreen) {\n        lines.remove(line);\n      }\n    }\n  };\n\n  const rampUpLine = line => {\n    let x = line.points[line.points.length - 1].x;\n    let y = line.points[line.points.length - 1].y + line.speed;\n\n    // Check is in circle\n    const allCircles = [...circles, circle];\n    for (const circle of allCircles) {\n      const distance = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);\n      const distanceDiff = distance - circle.r;\n      if (distanceDiff < 0) {\n        const angle = Math.atan2(y - circle.y, x - circle.x); // radians\n        const diffX = Math.cos(angle) * Math.abs(Math.sqrt(Math.abs(distanceDiff * (circle.r / 4 / line.speed))));\n        const diffY = Math.sin(angle) * Math.abs(Math.sqrt(Math.abs(distanceDiff * (circle.r / 4 / line.speed))));\n\n        if (Math.abs(diffX) > line.speed) {\n          lines.remove(line);\n          return;\n        }\n\n        x += diffX;\n        y += diffY;\n      }\n    }\n\n    if (line.points.length) {\n      const prevY = line.points[line.points.length - 1].y;\n\n      if (y < prevY || y === prevY) {\n        lines.remove(line);\n        return;\n      }\n    }\n\n    line.points.push({ x, y });\n    if (line.points.length > line.size) {\n      line.points = line.points.slice(1);\n    }\n  };\n\n  const createLine = () => {\n    const line = {\n      points: [{ x: random.range(0, width), y: random.range(fromY, toY) }],\n      speed: random.range(speedRange[0], speedRange[1]),\n      size: random.rangeFloor(sizeRange[0], sizeRange[1]),\n      color: random.pick(palette),\n    };\n\n    line.thickness = mapRange(line.speed, speedRange[0], speedRange[1], thicknessRange[0], thicknessRange[1]);\n\n    lines.add(line);\n  };\n\n  return ({ context, width, height }) => {\n    context.fillStyle = 'hsla(0, 0%, 10%, .5)';\n    context.fillRect(0, 0, width, height);\n\n    [...circles, circle].forEach(circle => {\n      context.strokeStyle = '#999';\n      context.beginPath();\n      context.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2, false);\n      context.stroke();\n    });\n\n    for (const line of lines) {\n      context.strokeStyle = line.color;\n      // context.lineWidth = line.thickness;\n\n      if (line.points.length > 2) {\n        const lineCoords = line.points.map((p, idx) => {\n          return [p.x, p.y, (idx / line.points.length) * line.thickness * 2];\n        });\n\n        const ropeCoords = rope(lineCoords);\n\n        drawLine(context, ropeCoords, true);\n      }\n\n      rampUpLine(line);\n    }\n\n    cleanLines();\n\n    for (let i = lines.size; i < maxLines; i += 1) {\n      createLine();\n    }\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}