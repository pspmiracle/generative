{"version":3,"sources":["sketches/024_skull_destroy/shaders/vert.glsl","sketches/024_skull_destroy/shaders/frag.glsl","sketches/024_skull_destroy/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","FromHexString","ShadersStore","particlesVertexShader","particlesFragmentShader","particlesFragShader","camera","Math","PI","setTarget","Zero","attachControl","intensity","ImportMeshAsync","meshes","skullMesh","target","pcs","addSurfacePoints","Stated","buildMeshAsync","mesh","particlesMaterial","vertex","fragment","attributes","uniforms","needAlphaBlending","pointsCloud","alphaMode","ALPHA_ADD","setFloat","material","dispose","render","time","alpha","aRatio","getEngine","getAspectRatio","setVector2","resize","pixelRatio","unload","settings","animate","context"],"mappings":"iHAAA,OAAe,ghD,iCCAf,OAAe,+iB,+FCSTA,EAAM,uCAAG,+CAAAC,EAAA,6DAASC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAILC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAaJ,SAAeK,cAAc,WAEhDL,SAAeM,aAAaC,sBAAwBA,UACpDP,SAAeM,aAAaE,wBAA0BC,WAGhDC,EAAS,IAAIV,kBACjB,WACCW,KAAKC,GAAK,EACXD,KAAKC,GAAK,EACV,IACA,IAAIZ,UAAgB,EAAG,EAAG,GAC1BG,IAIKU,UAAUb,UAAgBc,QAGjCJ,EAAOK,cAAcnB,GAAQ,GAGf,IAAII,mBAAyB,QAAS,IAAIA,UAAgB,EAAG,EAAG,GAAIG,GAG5Ea,UAAY,IAjCL,UAoCYhB,cAAoBiB,gBAAgB,GAAI,wBAAyB,gBAAiBd,GApC9F,wBAoCLe,EApCK,EAoCLA,OAEFC,EAAYD,EAAO,GAEzBR,EAAOU,OAASD,GAEVE,EAAM,IAAIrB,oBAA0B,MAAO,EAAGG,IAEhDmB,iBAAiBH,EAAW,IAAOnB,aAAmBuB,OAAQ,IAAIvB,SAAe,EAAG,EAAG,GAAI,KA5ClF,UA8CMqB,EAAIG,iBA9CV,eA8CPC,EA9CO,QAgDPC,EAAoB,IAAI1B,iBAC5B,SACAG,EACA,CACEwB,OAAQ,YACRC,SAAU,aAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,cAAe,SACxFC,mBAAmB,KAGLC,aAAc,EAEhCN,EAAkBO,UAAYjC,SAAekC,UAE7CR,EAAkBS,SAAS,cAAe,IAAInC,UAAgB,EAAG,IACjE0B,EAAkBS,SAAS,QAAS,GAEpCV,EAAKW,SAAWV,EAEhBP,EAAUkB,UAtEG,kBAwEN,CACLC,OADK,YACa,IAATC,EAAQ,EAARA,KACP7B,EAAO8B,OAAS,OAChBd,EAAkBS,SAAS,QAASI,GACpC,IAAME,EAAStC,EAAMuC,YAAYC,eAAejC,GAChDgB,EAAkBkB,WAAW,cAAe,IAAI5C,UAAgByC,EAAQ,IAExEtC,EAAMmC,UAERO,OATK,YASiC,EAA7BC,WAA6B,EAAjBjD,MAAiB,EAAVC,OAC1BC,EAAO8C,UAETE,OAZK,WAaHhD,EAAOsC,aArFE,4CAAH,sDA0FG,WAAE3C,SAAQsD,SA/FR,CACfC,SAAS,EACTC,QAAS","file":"static/js/41.7e91d493.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nvarying vec2 vUv;\\nvarying vec3 oPos;\\nvarying vec3 pPos;\\nvarying float mFactor;\\n\\nuniform float iTime;\\nuniform float pSize;\\n\\nuniform mat4 worldViewProjection;\\nuniform mat4 world;\\n\\n#define MOD3 vec3(.1031,.11369,.13787)\\n\\nvec3 hash33(vec3 p3)\\n{\\n  p3 = fract(p3 * MOD3);\\n  p3 += dot(p3, p3.yxz+19.19);\\n  return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\\n}\\n\\nfloat noise(vec3 p)\\n{\\n  const float K1 = 0.333333333;\\n  const float K2 = 0.166666667;\\n\\n  vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n  vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n\\n  vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n  vec3 i1 = e * (1.0 - e.zxy);\\n  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n\\n  vec3 d1 = d0 - (i1 - 1.0 * K2);\\n  vec3 d2 = d0 - (i2 - 2.0 * K2);\\n  vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n\\n  vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n  vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n\\n  return dot(vec4(31.316), n);\\n}\\n\\nvoid main()\\n{\\n  vUv = uv;\\n\\n  oPos = position;\\n  pPos = position;\\n\\n  float t = fract(iTime/5.)*5.;\\n  float f = noise(oPos*.5);\\n\\n  float moveFactor = (oPos.z*.02-(t*.5 + f*.3))*(10. + (pPos.y - oPos.y +50.)*1.)*t*step(pPos.z*.02, t*.5 + f*.3);\\n  pPos.y += moveFactor;\\n\\n  mFactor = moveFactor;\\n\\n  gl_PointSize = pSize;\\n\\n  gl_Position = worldViewProjection * vec4( pPos, 1.0 );\\n}\\n\";","export default \"#define GLSLIFY 1\\nvarying vec3 oPos;\\nvarying vec3 pPos;\\n\\nvarying vec2 vUv;\\nvarying float mFactor;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\n\\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\\n{\\n  vec2 uv = (vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  vec3 col = hue(oPos.z*.01 + .1).rgb;\\n\\n  fragColor = vec4(col, 1.- length(uv) + mFactor*.01);\\n}\\n\\nvoid main()\\n{\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport particlesVertexShader from './shaders/vert.glsl';\nimport particlesFragShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  // This creates a basic Babylon Scene object (non-mesh)\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = BABYLON.Color3.FromHexString('#182026');\n\n  BABYLON.Effect.ShadersStore.particlesVertexShader = particlesVertexShader;\n  BABYLON.Effect.ShadersStore.particlesFragmentShader = particlesFragShader;\n\n  // This creates and positions a free camera (non-mesh)\n  const camera = new BABYLON.ArcRotateCamera(\n    'camera1',\n    -Math.PI / 3,\n    Math.PI / 2,\n    100,\n    new BABYLON.Vector3(0, 0, 0),\n    scene,\n  );\n\n  // This targets the camera to scene origin\n  camera.setTarget(BABYLON.Vector3.Zero());\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n\n  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)\n  const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);\n\n  // Default intensity is 1. Let's dim the light a small amount\n  light.intensity = 0.75;\n\n  // The first parameter can be used to specify which mesh to import. Here we import all meshes\n  const { meshes } = await BABYLON.SceneLoader.ImportMeshAsync('', 'static/assets/models/', 'skull.babylon', scene);\n\n  const skullMesh = meshes[0];\n\n  camera.target = skullMesh;\n\n  const pcs = new BABYLON.PointsCloudSystem('pcs', 0, scene);\n\n  pcs.addSurfacePoints(skullMesh, 50000, BABYLON.PointColor.Stated, new BABYLON.Color3(1, 0, 0), 0.25);\n\n  const mesh = await pcs.buildMeshAsync();\n\n  const particlesMaterial = new BABYLON.ShaderMaterial(\n    'shader',\n    scene,\n    {\n      vertex: 'particles',\n      fragment: 'particles',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'iTime', 'iResolution', 'pSize'],\n      needAlphaBlending: true,\n    },\n  );\n  particlesMaterial.pointsCloud = true;\n\n  particlesMaterial.alphaMode = BABYLON.Engine.ALPHA_ADD;\n\n  particlesMaterial.setFloat('iResolution', new BABYLON.Vector2(1, 1));\n  particlesMaterial.setFloat('pSize', 2);\n\n  mesh.material = particlesMaterial;\n\n  skullMesh.dispose();\n\n  return {\n    render({ time }) {\n      camera.alpha += 0.00125;\n      particlesMaterial.setFloat('iTime', time);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      particlesMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}