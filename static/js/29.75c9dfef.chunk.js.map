{"version":3,"sources":["../node_modules/canvas-sketch-util/lib/wrap.js","../node_modules/canvas-sketch-util/math.js","../node_modules/point-in-polygon/index.js","utils/geometry.js","sketches/003_broken_space/index.js"],"names":["module","exports","value","from","to","TypeError","t","cycle","Math","floor","defined","require","wrap","EPSILON","Number","clamp","min","max","lerp","inverseLerp","abs","toFinite","n","defaultValue","isFinite","expandVector","dims","p","scalar","i","out","lerpArray","length","newArray","initialValue","push","mod","a","b","damp","lambda","dt","exp","fract","sign","degToRad","PI","radToDeg","pingPong","linspace","opts","endpoint","offset","map","_","lerpFrames","values","len","whole","frame","nextFrame","Array","isArray","clamp01","v","smoothstep","x","dampArray","mapRange","inputMin","inputMax","outputMin","outputMax","outVal","expand2D","expand3D","expand4D","point","vs","y","inside","j","xi","yi","xj","yj","isPointBetween","findSegmentIntersection","p1","p2","p3","p4","i1","findIntersection","pointsDistance","p1x","p1y","p2x","p2y","sqrt","getPointCoordsByAngleAndDistance","angle","distance","initPoint","xC","cos","yC","sin","isCircleInCircle","c1","c2","x0","y0","r0","x1","y1","r1","auto","hypot","twoCirclesIntersection","getCoordinates","dx","dy","d","x2","y2","h","rx","ry","xiPrime","yiPrime","circeIntersectWithCircles","circle","anotherCircles","intersect","aCircle","r","sketch","width","height","sx","sy","generateLine","lines","d1","random","pick","d2","ri","lowerDist","newLine","range","forEach","eLine","dist","prevTime","context","time","fillStyle","fillRect","lineWidth","beginPath","moveTo","lineTo","stroke","settings","dimensions","animate"],"mappings":"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","file":"static/js/29.75c9dfef.chunk.js","sourcesContent":["module.exports = wrap;\nfunction wrap (value, from, to) {\n  if (typeof from !== 'number' || typeof to !== 'number') {\n    throw new TypeError('Must specify \"to\" and \"from\" arguments as numbers');\n  }\n  // algorithm from http://stackoverflow.com/a/5852628/599884\n  if (from > to) {\n    var t = from;\n    from = to;\n    to = t;\n  }\n  var cycle = to - from;\n  if (cycle === 0) {\n    return to;\n  }\n  return value - cycle * Math.floor((value - from) / cycle);\n}\n","var defined = require('defined');\nvar wrap = require('./lib/wrap');\nvar EPSILON = Number.EPSILON;\n\nfunction clamp (value, min, max) {\n  return min < max\n    ? (value < min ? min : value > max ? max : value)\n    : (value < max ? max : value > min ? min : value);\n}\n\nfunction clamp01 (v) {\n  return clamp(v, 0, 1);\n}\n\nfunction lerp (min, max, t) {\n  return min * (1 - t) + max * t;\n}\n\nfunction inverseLerp (min, max, t) {\n  if (Math.abs(min - max) < EPSILON) return 0;\n  else return (t - min) / (max - min);\n}\n\nfunction smoothstep (min, max, t) {\n  var x = clamp(inverseLerp(min, max, t), 0, 1);\n  return x * x * (3 - 2 * x);\n}\n\nfunction toFinite (n, defaultValue) {\n  defaultValue = defined(defaultValue, 0);\n  return typeof n === 'number' && isFinite(n) ? n : defaultValue;\n}\n\nfunction expandVector (dims) {\n  if (typeof dims !== 'number') throw new TypeError('Expected dims argument');\n  return function (p, defaultValue) {\n    defaultValue = defined(defaultValue, 0);\n    var scalar;\n    if (p == null) {\n      // No vector, create a default one\n      scalar = defaultValue;\n    } else if (typeof p === 'number' && isFinite(p)) {\n      // Expand single channel to multiple vector\n      scalar = p;\n    }\n\n    var out = [];\n    var i;\n    if (scalar == null) {\n      for (i = 0; i < dims; i++) {\n        out[i] = toFinite(p[i], defaultValue);\n      }\n    } else {\n      for (i = 0; i < dims; i++) {\n        out[i] = scalar;\n      }\n    }\n    return out;\n  };\n}\n\nfunction lerpArray (min, max, t, out) {\n  out = out || [];\n  if (min.length !== max.length) {\n    throw new TypeError('min and max array are expected to have the same length');\n  }\n  for (var i = 0; i < min.length; i++) {\n    out[i] = lerp(min[i], max[i], t);\n  }\n  return out;\n}\n\nfunction newArray (n, initialValue) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  var out = [];\n  for (var i = 0; i < n; i++) out.push(initialValue);\n  return out;\n}\n\nfunction linspace (n, opts) {\n  n = defined(n, 0);\n  if (typeof n !== 'number') throw new TypeError('Expected n argument to be a number');\n  opts = opts || {};\n  if (typeof opts === 'boolean') {\n    opts = { endpoint: true };\n  }\n  var offset = defined(opts.offset, 0);\n  if (opts.endpoint) {\n    return newArray(n).map(function (_, i) {\n      return n <= 1 ? 0 : ((i + offset) / (n - 1));\n    });\n  } else {\n    return newArray(n).map(function (_, i) {\n      return (i + offset) / n;\n    });\n  }\n}\n\nfunction lerpFrames (values, t, out) {\n  t = clamp(t, 0, 1);\n\n  var len = values.length - 1;\n  var whole = t * len;\n  var frame = Math.floor(whole);\n  var fract = whole - frame;\n\n  var nextFrame = Math.min(frame + 1, len);\n  var a = values[frame % values.length];\n  var b = values[nextFrame % values.length];\n  if (typeof a === 'number' && typeof b === 'number') {\n    return lerp(a, b, fract);\n  } else if (Array.isArray(a) && Array.isArray(b)) {\n    return lerpArray(a, b, fract, out);\n  } else {\n    throw new TypeError('Mismatch in value type of two array elements: ' + frame + ' and ' + nextFrame);\n  }\n}\n\nfunction mod (a, b) {\n  return ((a % b) + b) % b;\n}\n\nfunction degToRad (n) {\n  return n * Math.PI / 180;\n}\n\nfunction radToDeg (n) {\n  return n * 180 / Math.PI;\n}\n\nfunction fract (n) {\n  return n - Math.floor(n);\n}\n\nfunction sign (n) {\n  if (n > 0) return 1;\n  else if (n < 0) return -1;\n  else return 0;\n}\n\n// Specific function from Unity / ofMath, not sure its needed?\n// function lerpWrap (a, b, t, min, max) {\n//   return wrap(a + wrap(b - a, min, max) * t, min, max)\n// }\n\nfunction pingPong (t, length) {\n  t = mod(t, length * 2);\n  return length - Math.abs(t - length);\n}\n\nfunction damp (a, b, lambda, dt) {\n  return lerp(a, b, 1 - Math.exp(-lambda * dt));\n}\n\nfunction dampArray (a, b, lambda, dt, out) {\n  out = out || [];\n  for (var i = 0; i < a.length; i++) {\n    out[i] = damp(a[i], b[i], lambda, dt);\n  }\n  return out;\n}\n\nfunction mapRange (value, inputMin, inputMax, outputMin, outputMax, clamp) {\n  // Reference:\n  // https://openframeworks.cc/documentation/math/ofMath/\n  if (Math.abs(inputMin - inputMax) < EPSILON) {\n    return outputMin;\n  } else {\n    var outVal = ((value - inputMin) / (inputMax - inputMin) * (outputMax - outputMin) + outputMin);\n    if (clamp) {\n      if (outputMax < outputMin) {\n        if (outVal < outputMax) outVal = outputMax;\n        else if (outVal > outputMin) outVal = outputMin;\n      } else {\n        if (outVal > outputMax) outVal = outputMax;\n        else if (outVal < outputMin) outVal = outputMin;\n      }\n    }\n    return outVal;\n  }\n}\n\nmodule.exports = {\n  mod: mod,\n  fract: fract,\n  sign: sign,\n  degToRad: degToRad,\n  radToDeg: radToDeg,\n  wrap: wrap,\n  pingPong: pingPong,\n  linspace: linspace,\n  lerp: lerp,\n  lerpArray: lerpArray,\n  inverseLerp: inverseLerp,\n  lerpFrames: lerpFrames,\n  clamp: clamp,\n  clamp01: clamp01,\n  smoothstep: smoothstep,\n  damp: damp,\n  dampArray: dampArray,\n  mapRange: mapRange,\n  expand2D: expandVector(2),\n  expand3D: expandVector(3),\n  expand4D: expandVector(4)\n};\n","module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","import pointInsidePolygon from 'point-in-polygon';\n\n/**\n * Get vectors intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {number[]}\n */\nexport function findIntersection(p1, p2, p3, p4) {\n  const x =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[0] - p4[0]) - (p1[0] - p2[0]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  const y =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  return [x, y];\n}\n\n/**\n * Is point on line\n * @param p\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction isPointBetween(p, a, b) {\n  return (\n    ((a[0] <= p[0] && p[0] <= b[0]) || (a[0] >= p[0] && p[0] >= b[0])) &&\n    ((a[1] <= p[1] && p[1] <= b[1]) || (a[1] >= p[1] && p[1] >= b[1]))\n  );\n}\n\n/**\n * Get segments intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {*}\n */\nexport function findSegmentIntersection(p1, p2, p3, p4) {\n  const i1 = findIntersection(p1, p2, p3, p4);\n\n  const isIntersected = isPointBetween(i1, p1, p2) && isPointBetween(i1, p3, p4);\n  return isIntersected ? i1 : false;\n}\n\n/**\n * Get two points distance\n * @returns {number}\n * @param p1x\n * @param p1y\n * @param p2x\n * @param p2y\n */\nexport function pointsDistance(p1x, p1y, p2x, p2y) {\n  return Math.sqrt((p1x - p2x) ** 2 + (p1y - p2y) ** 2);\n}\n\n/**\n * Length of segment\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns {number}\n */\nexport function lineLength([x1, y1], [x2, y2]) {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n *\n * @param angle (RADIANS)\n * @param distance\n * @param initPoint\n * @returns {number[]}\n */\nexport function getPointCoordsByAngleAndDistance(angle, distance, initPoint = [0, 0]) {\n  const xC = distance * Math.cos(angle);\n  const yC = distance * Math.sin(angle);\n  return [initPoint[0] + xC, initPoint[1] + yC];\n}\n\n/**\n * Determine if circle is fully places in another one\n * @param c1\n * @param c2\n * @param auto - automatic set smaller circle on first place\n * @returns {boolean}\n */\nexport function isCircleInCircle(c1, c2, auto = false) {\n  let x0;\n  let y0;\n  let r0;\n  let x1;\n  let y1;\n  let r1;\n\n  if (!auto || c2.r1 >= c1.r1) {\n    [x0, y0, r0] = c1;\n    [x1, y1, r1] = c2;\n  } else {\n    [x1, y1, r1] = c2;\n    [x0, y0, r0] = c1;\n  }\n\n  return r1 >= Math.hypot(x1 - x0, y1 - y0) + r0;\n}\n\n/**\n * Get two circles intersection\n *\n * Original: https://stackoverflow.com/a/12221389/1531295\n *\n * @param x0\n * @param y0\n * @param r0\n * @param x1\n * @param y1\n * @param r1\n * @param getCoordinates\n */\nexport function twoCirclesIntersection([x0, y0, r0], [x1, y1, r1], getCoordinates = true) {\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  const dx = x1 - x0;\n  const dy = y1 - y0;\n\n  /* Determine the straight-line distance between the centers. */\n  const d = Math.hypot(dy, dx);\n\n  /* Check for solvability. */\n  if (d > r0 + r1) {\n    /* no solution. circles do not intersect. */\n    return false;\n  }\n  if (d < Math.abs(r0 - r1)) {\n    /* no solution. one circle is contained in the other */\n    return false;\n  }\n\n  if (!getCoordinates) {\n    return true;\n  }\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.\n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  const a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);\n\n  /* Determine the coordinates of point 2. */\n  const x2 = x0 + (dx * a) / d;\n  const y2 = y0 + (dy * a) / d;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n  const h = Math.sqrt(r0 * r0 - a * a);\n\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  const rx = -dy * (h / d);\n  const ry = dx * (h / d);\n\n  /* Determine the absolute intersection points. */\n  const xi = x2 + rx;\n  const xiPrime = x2 - rx;\n  const yi = y2 + ry;\n  const yiPrime = y2 - ry;\n\n  return [xi, xiPrime, yi, yiPrime];\n}\n\nexport function circeIntersectWithCircles(circle, anotherCircles) {\n  let intersect = false;\n  for (let i = 0; i < anotherCircles.length; i += 1) {\n    const aCircle = anotherCircles[i];\n    intersect =\n      intersect ||\n      twoCirclesIntersection([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], false) ||\n      isCircleInCircle([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], true);\n    if (intersect) {\n      break;\n    }\n  }\n  return intersect;\n}\n\n/**\n * Check circle is in polygon\n * @param cx\n * @param cy\n * @param cr\n * @param polygon\n * @returns {boolean}\n */\nexport function circleInPolygon([cx, cy, cr], polygon) {\n  // Check center inside first\n  if (!pointInsidePolygon([cx, cy], polygon)) {\n    return false;\n  }\n\n  // Get 7 points of contour and check them\n  for (let angle = -Math.PI * 2; angle < Math.PI; angle += Math.PI / 4) {\n    const xC = cr * Math.cos(angle);\n    const yC = cr * Math.sin(angle);\n\n    const p = [xC + cx, yC + cy];\n\n    if (!pointInsidePolygon(p, polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Make angle in range of [-Math.PI, Math.PI]\n * @param a\n * @returns {number}\n */\nexport function simpleAngle(a) {\n  if (a >= Math.PI * 2) {\n    return a - Math.PI * 2;\n  }\n  if (a < 0) {\n    return a + Math.PI * 2;\n  }\n  return a;\n}\n\n/**\n * Calculate angle of reflect\n * @param incidenceAngle\n * @param surfaceAngle\n * @returns {number}\n */\nexport function angleReflect(incidenceAngle, surfaceAngle) {\n  return simpleAngle(surfaceAngle * 2 - incidenceAngle);\n}\n","import random from 'canvas-sketch-util/random';\nimport { lerp } from 'canvas-sketch-util/math';\nimport { findSegmentIntersection, pointsDistance } from '@/utils/geometry';\n\nconst settings = {\n  dimensions: [2048, 2048],\n  animate: true,\n};\n\nconst sketch = ({ width, height }) => {\n  const margin = 0;\n\n  const sx = v => lerp(margin, width - margin, v);\n  const sy = v => lerp(margin, height - margin, v);\n\n  const generateLine = lines => {\n    const zone1 = [\n      [\n        [0, 0.25],\n        [0, 1],\n      ], // p1\n      [\n        [0, 1],\n        [0.75, 1],\n      ], // p2\n    ];\n    const zone2 = [\n      [\n        [0.25, 0],\n        [1, 0],\n      ], // p1\n      [\n        [1, 0],\n        [1, 0.75],\n      ], // p2\n    ];\n\n    let d1 = random.pick(zone1);\n    let d2 = random.pick(zone2);\n\n    if (random.value() > 0.5) {\n      [d1, d2] = [d2, d1];\n    }\n\n    const x1 = random.range(d1[0][0], d1[1][0]);\n    const y1 = random.range(d1[0][1], d1[1][1]);\n\n    const x2 = random.range(d2[0][0], d2[1][0]);\n    const y2 = random.range(d2[0][1], d2[1][1]);\n\n    const newLine = { p1: [x1, y1], p2: [x2, y2] };\n\n    let i;\n    let ri;\n    let lowerDist;\n    lines.forEach(eLine => {\n      i = findSegmentIntersection(\n        [eLine.p1[0], eLine.p1[1]],\n        [eLine.p2[0], eLine.p2[1]],\n        [newLine.p1[0], newLine.p1[1]],\n        [newLine.p2[0], newLine.p2[1]],\n      );\n\n      if (i) {\n        const dist = pointsDistance(newLine.p1[0], newLine.p1[1], i[0], i[1]);\n        if (!lowerDist || dist < lowerDist) {\n          ri = i;\n          lowerDist = dist;\n        }\n      }\n    });\n\n    if (ri) {\n      newLine.p2 = ri;\n    }\n\n    return newLine;\n  };\n\n  let prevTime = -10;\n\n  return ({ context, width, height, time }) => {\n    if (time - prevTime < 2) {\n      return;\n    }\n    prevTime = time;\n\n    const lines = [];\n\n    for (let i = 0; i < 150; i += 1) {\n      lines.push(generateLine(lines));\n    }\n\n    context.fillStyle = 'hsl(0, 0%, 98%)';\n    context.fillRect(0, 0, width, height);\n\n    context.lineWidth = width * 0.001;\n\n    lines.forEach(({ p1, p2 }) => {\n      context.beginPath();\n      context.moveTo(sx(p1[0]), sy(p1[1]));\n      context.lineTo(sx(p2[0]), sy(p2[1]));\n      context.stroke();\n    });\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}