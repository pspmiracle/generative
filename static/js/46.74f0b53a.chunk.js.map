{"version":3,"sources":["sketches/045_circle_worms/shaders/vert.glsl","sketches/045_circle_worms/shaders/frag.glsl","sketches/045_circle_worms/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","ShadersStore","particlesVertexShader","particlesFragmentShader","particlesFragShader","camera","setTarget","Zero","mode","ORTHOGRAPHIC_CAMERA","orthoTop","orthoBottom","orthoLeft","orthoRight","pcs","sizeStep","stackSize","ratio","getEngine","getAspectRatio","wormsCount","wormPositions","i","x","Math","random","y","push","forEach","addPoints","particle","position","buildMeshAsync","particlesMaterial","vertex","fragment","attributes","uniforms","needAlphaBlending","pointsCloud","setFloat","mesh","material","render","time","aRatio","setVector2","resize","pixelRatio","unload","dispose","settings","animate","context"],"mappings":"mHAAA,OAAe,w8H,iCCAf,OAAe,g5B,uGCSTA,EAAM,uCAAG,2DAAAC,EAAA,sDAgCb,IAhCsBC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAGLC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAa,IAAIJ,SAAe,GAAK,IAAK,GAAK,IAAK,GAAK,KAE/DA,SAAeK,aAAaC,sBAAwBA,UACpDN,SAAeK,aAAaE,wBAA0BC,WAEhDC,EAAS,IAAIT,kBAAwB,UAAW,EAAG,EAAG,IAAOA,UAAgB,GAAI,EAAG,GAAIG,IACvFO,UAAUV,UAAgBW,QAEjCF,EAAOG,KAAOZ,SAAea,oBAE7BJ,EAAOK,SAAW,EAClBL,EAAOM,aAAe,EACtBN,EAAOO,WAAa,EACpBP,EAAOQ,WAAa,EAEdC,EAAM,IAAIlB,oBAA0B,MAAO,EAAGG,GAE9CgB,EAAW,IAEXC,EAAY,IAEZC,EAAQlB,EAAMmB,YAAYC,eAAed,GAEzCe,EAAa,IAAMH,EACnBI,EAAgB,GACbC,EAAI,EAAGA,EAAIF,EAAYE,GAAK,EAC7BC,EAA4B,GAAvBC,KAAKC,SAAW,IACrBC,EAA4B,GAAvBF,KAAKC,SAAW,IAAWR,EAEtCI,EAAcM,KAAK,CAACJ,EAAGG,IAGzB,IAvCa,WAuCJJ,GACPD,EAAcO,SAAQ,YAAa,IAAD,mBAAVL,EAAU,KAAPG,EAAO,KAChCZ,EAAIe,UAAU,GAAG,SAAAC,GACfA,EAASC,SAAW,IAAInC,UAAgB2B,EAAGD,EAAGI,UAH3CJ,EAAI,EAAGA,EAAIN,EAAWM,GAAK,EAAI,EAA/BA,GAvCI,iBA+CPR,EAAIkB,iBA/CG,eAiDPC,EAAoB,IAAIrC,iBAC5B,SACAG,EACA,CACEmC,OAAQ,YACRC,SAAU,aAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CACR,QACA,YACA,sBACA,OACA,QACA,cACA,QACA,YACA,WACA,UAEFC,mBAAmB,KAGLC,aAAc,EAEhCN,EAAkBO,SAAS,cAAe,IAAI5C,UAAgB,EAAG,IACjEqC,EAAkBO,SAAS,QAAS,GACpCP,EAAkBO,SAAS,YAAaxB,GACxCiB,EAAkBO,SAAS,WAAYzB,GACvCkB,EAAkBO,SAAS,SAAU,GAErC1B,EAAI2B,KAAKC,SAAWT,EAjFP,kBAmFN,CACLU,OADK,YAC4B,IAAxBC,EAAuB,EAAvBA,KAAMnD,EAAiB,EAAjBA,MAAOC,EAAU,EAAVA,OACpBuC,EAAkBO,SAAS,QAASI,GACpCX,EAAkBO,SAAS,SAAU/C,EAAQC,GAC7C,IAAMmD,EAAS9C,EAAMmB,YAAYC,eAAed,GAChD4B,EAAkBa,WAAW,cAAe,IAAIlD,UAAgBiD,EAAQ,IAExE9C,EAAM4C,UAERI,OATK,YASiC,EAA7BC,WAA6B,EAAjBvD,MAAiB,EAAVC,OAC1BC,EAAOoD,UAETE,OAZK,WAaHtD,EAAOuD,aAhGE,4CAAH,sDAqGG,WAAE5D,SAAQ6D,SA1GR,CACfC,SAAS,EACTC,QAAS","file":"static/js/46.74f0b53a.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nvarying vec2 vUv;\\nvarying vec3 pPos;\\nvarying float rSize;\\n\\nuniform float iTime;\\nuniform float aRatio;\\nuniform float stackSize;\\nuniform float sizeStep;\\nuniform float pSize;\\nuniform vec3 camPos;\\n\\nuniform mat4 worldViewProjection;\\nuniform mat4 world;\\n\\n#define PI 3.1415926;\\n#define PI2 6.28318530;\\n#define rand1(p) fract(sin(p * 78.233) * 43758.5453)\\n\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvoid main()\\n{\\n    vUv = uv;\\n    pPos = position;\\n\\n    gl_PointSize = stackSize * sizeStep - position.y * sizeStep;\\n\\n    pPos.x += position.y*.01;\\n    rSize = gl_PointSize;\\n\\n    float depth = position.y / stackSize;\\n    float df =  (1. - depth);\\n\\n    float t = iTime;\\n\\n    vec3 p  = position * 100.;\\n\\n    float xf = snoise(vec3(p.x + depth, depth + t, p.z + depth)) *.15 * depth;\\n    float zf = snoise(vec3(p.x + depth + 100., depth + t, p.z + depth)) *.15  * depth;\\n\\n    pPos.x += xf - depth*.25;\\n    pPos.z += zf + depth*.125;\\n\\n    pPos.z /= aRatio;\\n\\n    gl_Position = worldViewProjection * vec4(pPos, 1.0);\\n\\n}\\n\";","export default \"#define GLSLIFY 1\\nvarying vec3 pPos;\\nvarying float rSize;\\n\\nvarying vec2 vUv;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\nuniform float stackSize;\\n\\n#define BLACK_COL vec3(16,22,26)/255.\\n#define WHITE_COL vec3(235,241,245)/255.\\n\\n#define SF 2./min(iResolution.x, iResolution.y)\\n#define SS(l, s) smoothstep(SF, -SF, l - s)\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\\n{\\n    vec2 uv = (vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n    float l = length(uv);\\n\\n    float sf = 2./rSize;\\n\\n    float circleLimit = smoothstep(.5, .5 - sf, l);\\n\\n    float ll = .1;\\n    float g = smoothstep(sf, -sf, abs(l - (.5 - sf * 1.75)));\\n\\n    float depthFactor = pPos.y / stackSize;\\n\\n    vec3 col = mix(BLACK_COL, WHITE_COL, g * depthFactor);\\n\\n    fragColor = vec4(col, circleLimit);\\n}\\n\\nvoid main()\\n{\\n    mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport particlesVertexShader from './shaders/vert.glsl';\nimport particlesFragShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = new BABYLON.Color3(16 / 255, 22 / 255, 26 / 255);\n\n  BABYLON.Effect.ShadersStore.particlesVertexShader = particlesVertexShader;\n  BABYLON.Effect.ShadersStore.particlesFragmentShader = particlesFragShader;\n\n  const camera = new BABYLON.ArcRotateCamera('camera1', 0, 0, 10000, BABYLON.Vector3(0, -1, 1), scene);\n  camera.setTarget(BABYLON.Vector3.Zero());\n  // camera.attachControl(canvas, true);\n  camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;\n\n  camera.orthoTop = 1;\n  camera.orthoBottom = -1;\n  camera.orthoLeft = -1;\n  camera.orthoRight = 1;\n\n  const pcs = new BABYLON.PointsCloudSystem('pcs', 0, scene);\n\n  const sizeStep = 0.75;\n\n  const stackSize = 150;\n\n  const ratio = scene.getEngine().getAspectRatio(camera);\n\n  const wormsCount = 200 * ratio;\n  const wormPositions = [];\n  for (let i = 0; i < wormsCount; i += 1) {\n    const x = (Math.random() - 0.5) * 2;\n    const y = (Math.random() - 0.5) * 2 * ratio;\n\n    wormPositions.push([x, y]);\n  }\n\n  for (let i = 0; i < stackSize; i += 1) {\n    wormPositions.forEach(([x, y]) => {\n      pcs.addPoints(1, particle => {\n        particle.position = new BABYLON.Vector3(x, i, y);\n      });\n    });\n  }\n\n  await pcs.buildMeshAsync();\n\n  const particlesMaterial = new BABYLON.ShaderMaterial(\n    'shader',\n    scene,\n    {\n      vertex: 'particles',\n      fragment: 'particles',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: [\n        'world',\n        'worldView',\n        'worldViewProjection',\n        'view',\n        'iTime',\n        'iResolution',\n        'pSize',\n        'stackSize',\n        'sizeStep',\n        'aRatio',\n      ],\n      needAlphaBlending: true,\n    },\n  );\n  particlesMaterial.pointsCloud = true;\n\n  particlesMaterial.setFloat('iResolution', new BABYLON.Vector2(1, 1));\n  particlesMaterial.setFloat('pSize', 1);\n  particlesMaterial.setFloat('stackSize', stackSize);\n  particlesMaterial.setFloat('sizeStep', sizeStep);\n  particlesMaterial.setFloat('aRatio', 1);\n\n  pcs.mesh.material = particlesMaterial;\n\n  return {\n    render({ time, width, height }) {\n      particlesMaterial.setFloat('iTime', time);\n      particlesMaterial.setFloat('aRatio', width / height);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      particlesMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}