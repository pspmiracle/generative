{"version":3,"sources":["../node_modules/point-in-polygon/index.js","utils/ctx.js","utils/geometry.js","../node_modules/vec2-copy/index.js","utils/shape.js","../node_modules/chaikin-smooth/index.js","sketches/009_lines_magic/index.js"],"names":["module","exports","point","vs","x","y","inside","i","j","length","xi","yi","xj","yj","setDrawPolygon","context","lineCoords","closePath","beginPath","p","moveTo","lineTo","drawLine","stroke","isPointBetween","a","b","findSegmentIntersection","p1","p2","p3","p4","i1","findIntersection","pointsDistance","p1x","p1y","p2x","p2y","Math","sqrt","getPointCoordsByAngleAndDistance","angle","distance","initPoint","xC","cos","yC","sin","isCircleInCircle","c1","c2","x0","y0","r0","x1","y1","r1","auto","hypot","twoCirclesIntersection","getCoordinates","dx","dy","d","abs","x2","y2","h","rx","ry","xiPrime","yiPrime","circeIntersectWithCircles","circle","anotherCircles","intersect","aCircle","r","out","rope","coords","lineContour1","lineContour2","forEach","idx","pB","atan2","PI","rotate","push","reverse","smoothPath","path","level","chaikinSmooth","circleTree","maxTriesFindNewPoint","tension","newBranchTension","maxGenerations","minRadius","reduceRadiusFactor","maxBends","subTreesFromNode","limitPolygon","reduceRadiusOnFail","newPointSearchAngel","newBranchSearchAngel","allPoints","branches","makeBranch","beforePoint","generation","branch","isRoot","bPoint","tries","foundPoint","rad","random","range","pointInsidePolygon","comparingPoints","filter","slice","copy","require","input","output","Array","isArray","p0","p0x","p0y","Q","R","sketch","width","height","cubeVertices","initView","mat4","create","sections","time","fillStyle","fillRect","modelView","clone","rotateX","rotateY","rotateZ","sF","scale","map","pT","vec3","transformMat4","kId","section","lineWidth","strokeStyle","settings","dimensions","animate"],"mappings":"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","file":"static/js/21.2dc51548.chunk.js","sourcesContent":["module.exports = function (point, vs) {\n    // ray-casting algorithm based on\n    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html\n    \n    var x = point[0], y = point[1];\n    \n    var inside = false;\n    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {\n        var xi = vs[i][0], yi = vs[i][1];\n        var xj = vs[j][0], yj = vs[j][1];\n        \n        var intersect = ((yi > y) != (yj > y))\n            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);\n        if (intersect) inside = !inside;\n    }\n    \n    return inside;\n};\n","export function setDrawPolygon(context, lineCoords, closePath = false) {\n  context.beginPath();\n  for (let i = 0; i < lineCoords.length; i += 1) {\n    const p = lineCoords[i];\n    if (i === 0) {\n      context.moveTo(p[0], p[1]);\n    } else {\n      context.lineTo(p[0], p[1]);\n    }\n  }\n  if (closePath) {\n    context.closePath();\n  }\n}\n\nexport const drawLine = (context, lineCoords, closePath = false) => {\n  setDrawPolygon(context, lineCoords, closePath);\n  context.stroke();\n};\n\nexport function setPixel(imgData, x, y, cR, cG, cB, cA = 255) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  imgData.data[n] = ~~cR;\n  imgData.data[n + 1] = ~~cG;\n  imgData.data[n + 2] = ~~cB;\n  imgData.data[n + 3] = ~~cA;\n}\n\nconst resultGetPixelArray = [0, 0, 0, 0];\nexport function getPixel(imgData, x, y, colorNumber) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  if (colorNumber !== undefined) {\n    return imgData.data[n + colorNumber];\n  }\n\n  for (let i = 0; i < 4; i += 1) {\n    resultGetPixelArray[i] = n + i;\n  }\n  return resultGetPixelArray;\n}\n","import pointInsidePolygon from 'point-in-polygon';\n\n/**\n * Get vectors intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {number[]}\n */\nexport function findIntersection(p1, p2, p3, p4) {\n  const x =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[0] - p4[0]) - (p1[0] - p2[0]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  const y =\n    ((p1[0] * p2[1] - p2[0] * p1[1]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] * p4[1] - p3[1] * p4[0])) /\n    ((p1[0] - p2[0]) * (p3[1] - p4[1]) - (p1[1] - p2[1]) * (p3[0] - p4[0]));\n  return [x, y];\n}\n\n/**\n * Is point on line\n * @param p\n * @param a\n * @param b\n * @returns {boolean}\n */\nfunction isPointBetween(p, a, b) {\n  return (\n    ((a[0] <= p[0] && p[0] <= b[0]) || (a[0] >= p[0] && p[0] >= b[0])) &&\n    ((a[1] <= p[1] && p[1] <= b[1]) || (a[1] >= p[1] && p[1] >= b[1]))\n  );\n}\n\n/**\n * Get segments intersection\n * @param p1\n * @param p2\n * @param p3\n * @param p4\n * @returns {*}\n */\nexport function findSegmentIntersection(p1, p2, p3, p4) {\n  const i1 = findIntersection(p1, p2, p3, p4);\n\n  const isIntersected = isPointBetween(i1, p1, p2) && isPointBetween(i1, p3, p4);\n  return isIntersected ? i1 : false;\n}\n\n/**\n * Get two points distance\n * @returns {number}\n * @param p1x\n * @param p1y\n * @param p2x\n * @param p2y\n */\nexport function pointsDistance(p1x, p1y, p2x, p2y) {\n  return Math.sqrt((p1x - p2x) ** 2 + (p1y - p2y) ** 2);\n}\n\n/**\n * Length of segment\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns {number}\n */\nexport function lineLength([x1, y1], [x2, y2]) {\n  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);\n}\n\n/**\n *\n * @param angle (RADIANS)\n * @param distance\n * @param initPoint\n * @returns {number[]}\n */\nexport function getPointCoordsByAngleAndDistance(angle, distance, initPoint = [0, 0]) {\n  const xC = distance * Math.cos(angle);\n  const yC = distance * Math.sin(angle);\n  return [initPoint[0] + xC, initPoint[1] + yC];\n}\n\n/**\n * Determine if circle is fully places in another one\n * @param c1\n * @param c2\n * @param auto - automatic set smaller circle on first place\n * @returns {boolean}\n */\nexport function isCircleInCircle(c1, c2, auto = false) {\n  let x0;\n  let y0;\n  let r0;\n  let x1;\n  let y1;\n  let r1;\n\n  if (!auto || c2.r1 >= c1.r1) {\n    [x0, y0, r0] = c1;\n    [x1, y1, r1] = c2;\n  } else {\n    [x1, y1, r1] = c2;\n    [x0, y0, r0] = c1;\n  }\n\n  return r1 >= Math.hypot(x1 - x0, y1 - y0) + r0;\n}\n\n/**\n * Get two circles intersection\n *\n * Original: https://stackoverflow.com/a/12221389/1531295\n *\n * @param x0\n * @param y0\n * @param r0\n * @param x1\n * @param y1\n * @param r1\n * @param getCoordinates\n */\nexport function twoCirclesIntersection([x0, y0, r0], [x1, y1, r1], getCoordinates = true) {\n  /* dx and dy are the vertical and horizontal distances between\n   * the circle centers.\n   */\n  const dx = x1 - x0;\n  const dy = y1 - y0;\n\n  /* Determine the straight-line distance between the centers. */\n  const d = Math.hypot(dy, dx);\n\n  /* Check for solvability. */\n  if (d > r0 + r1) {\n    /* no solution. circles do not intersect. */\n    return false;\n  }\n  if (d < Math.abs(r0 - r1)) {\n    /* no solution. one circle is contained in the other */\n    return false;\n  }\n\n  if (!getCoordinates) {\n    return true;\n  }\n\n  /* 'point 2' is the point where the line through the circle\n   * intersection points crosses the line between the circle\n   * centers.\n   */\n\n  /* Determine the distance from point 0 to point 2. */\n  const a = (r0 * r0 - r1 * r1 + d * d) / (2.0 * d);\n\n  /* Determine the coordinates of point 2. */\n  const x2 = x0 + (dx * a) / d;\n  const y2 = y0 + (dy * a) / d;\n\n  /* Determine the distance from point 2 to either of the\n   * intersection points.\n   */\n  const h = Math.sqrt(r0 * r0 - a * a);\n\n  /* Now determine the offsets of the intersection points from\n   * point 2.\n   */\n  const rx = -dy * (h / d);\n  const ry = dx * (h / d);\n\n  /* Determine the absolute intersection points. */\n  const xi = x2 + rx;\n  const xiPrime = x2 - rx;\n  const yi = y2 + ry;\n  const yiPrime = y2 - ry;\n\n  return [xi, xiPrime, yi, yiPrime];\n}\n\nexport function circeIntersectWithCircles(circle, anotherCircles) {\n  let intersect = false;\n  for (let i = 0; i < anotherCircles.length; i += 1) {\n    const aCircle = anotherCircles[i];\n    intersect =\n      intersect ||\n      twoCirclesIntersection([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], false) ||\n      isCircleInCircle([circle.x, circle.y, circle.r], [aCircle.x, aCircle.y, aCircle.r], true);\n    if (intersect) {\n      break;\n    }\n  }\n  return intersect;\n}\n\n/**\n * Check circle is in polygon\n * @param cx\n * @param cy\n * @param cr\n * @param polygon\n * @returns {boolean}\n */\nexport function circleInPolygon([cx, cy, cr], polygon) {\n  // Check center inside first\n  if (!pointInsidePolygon([cx, cy], polygon)) {\n    return false;\n  }\n\n  // Get 7 points of contour and check them\n  for (let angle = -Math.PI * 2; angle < Math.PI; angle += Math.PI / 4) {\n    const xC = cr * Math.cos(angle);\n    const yC = cr * Math.sin(angle);\n\n    const p = [xC + cx, yC + cy];\n\n    if (!pointInsidePolygon(p, polygon)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Make angle in range of [-Math.PI, Math.PI]\n * @param a\n * @returns {number}\n */\nexport function simpleAngle(a) {\n  if (a >= Math.PI * 2) {\n    return a - Math.PI * 2;\n  }\n  if (a < 0) {\n    return a + Math.PI * 2;\n  }\n  return a;\n}\n\n/**\n * Calculate angle of reflect\n * @param incidenceAngle\n * @param surfaceAngle\n * @returns {number}\n */\nexport function angleReflect(incidenceAngle, surfaceAngle) {\n  return simpleAngle(surfaceAngle * 2 - incidenceAngle);\n}\n","module.exports = function vec2Copy(out, a) {\n    out[0] = a[0]\n    out[1] = a[1]\n    return out\n}","import random from 'canvas-sketch-util/random';\nimport pointInsidePolygon from 'point-in-polygon';\nimport chaikinSmooth from 'chaikin-smooth';\nimport { circeIntersectWithCircles, getPointCoordsByAngleAndDistance } from './geometry';\n\n/**\n * Get rope shape contour coordinates\n * @param coords [[x,y,r]...]\n */\nexport function rope(coords) {\n  const lineContour1 = [];\n  const lineContour2 = [];\n\n  coords.forEach((p, idx) => {\n    let pB;\n    if (idx === 0) {\n      pB = coords[idx + 1];\n    } else {\n      pB = coords[idx - 1];\n    }\n\n    let angle;\n\n    if (idx === 0) {\n      angle = Math.atan2(p[1] - pB[1], p[0] - pB[0]); // radians\n    } else {\n      angle = Math.atan2(pB[1] - p[1], pB[0] - p[0]); // radians\n    }\n\n    [-(Math.PI / 2), -(Math.PI / 2) * 3].forEach((rotate, idx) => {\n      const xC = p[2] * Math.cos(angle + rotate);\n      const yC = p[2] * Math.sin(angle + rotate);\n\n      if (idx % 2) {\n        lineContour1.push([xC + p[0], yC + p[1]]);\n      } else {\n        lineContour2.push([xC + p[0], yC + p[1]]);\n      }\n    });\n  });\n\n  return [...lineContour1, ...lineContour2.reverse()];\n}\n\nexport function smoothPath(path, level = 0) {\n  path = chaikinSmooth(path);\n  if (level === 0) {\n    return path;\n  }\n  return smoothPath(path, level - 1);\n}\n\nexport function circleTree({\n  x = 0,\n  y = 0,\n  r = 0.5,\n  angle = -Math.PI / 2,\n\n  maxTriesFindNewPoint = 3,\n  tension = 2,\n  newBranchTension = 2,\n  maxGenerations = 8,\n  minRadius = 0.005,\n  reduceRadiusFactor = 0.95,\n  maxBends = 100,\n  subTreesFromNode = 5,\n  limitPolygon,\n  reduceRadiusOnFail = false,\n  newPointSearchAngel = Math.PI / 6,\n  newBranchSearchAngel = Math.PI / 3,\n} = {}) {\n  let allPoints = [];\n  const branches = [];\n  const makeBranch = ({ x, y, r, angle }, beforePoint = null, generation = 1) => {\n    if (generation > maxGenerations) {\n      return;\n    }\n\n    let branch = [];\n    for (let i = 0; i < maxBends; i += 1) {\n      if (i === 0) {\n        const point = {\n          x,\n          y,\n          r,\n          isRoot: true,\n          generation,\n        };\n        branch.push(point);\n        allPoints.push(point);\n      } else {\n        const bPoint = branch[i - 1];\n\n        let tries = 0;\n        let foundPoint = false;\n        let point;\n        while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n          tries += 1;\n\n          const rad = random.range(angle - newPointSearchAngel, angle + newPointSearchAngel);\n          const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * tension, [bPoint.x, bPoint.y]);\n          point = {\n            x: coords[0],\n            y: coords[1],\n            r: bPoint.r * reduceRadiusFactor - ((1 - 1 / tries) * bPoint.r) / 5,\n            generation,\n            angle: rad,\n          };\n\n          if (limitPolygon && !pointInsidePolygon([point.x, point.y], limitPolygon)) {\n            // eslint-disable-next-line no-continue\n            continue;\n          }\n\n          // Stop if radius too small\n          if (point.r < minRadius) {\n            break;\n          }\n\n          // eslint-disable-next-line no-loop-func\n          const comparingPoints = allPoints.filter(p => {\n            return p !== branch[branch.length - 1];\n          });\n\n          if (!circeIntersectWithCircles(point, comparingPoints)) {\n            branch.push(point);\n            allPoints.push(point);\n            foundPoint = true;\n          }\n        }\n\n        // If could not find optimal position - stop\n        if (!foundPoint) {\n          break;\n        }\n\n        // From N-th node create sub branches\n        if (i > subTreesFromNode) {\n          tries = 0;\n          foundPoint = false;\n          while (!foundPoint && tries < maxTriesFindNewPoint && bPoint) {\n            tries += 1;\n\n            const rad = random.range(angle - newBranchSearchAngel, angle + newBranchSearchAngel);\n            const coords = getPointCoordsByAngleAndDistance(rad, bPoint.r * newBranchTension, [bPoint.x, bPoint.y]);\n            point = {\n              x: coords[0],\n              y: coords[1],\n              r: bPoint.r * reduceRadiusFactor - (reduceRadiusOnFail ? ((1 - 1 / tries) * bPoint.r) / 2 : 0),\n            };\n\n            // eslint-disable-next-line no-loop-func\n            const comparingPoints = allPoints.filter(p => {\n              return p !== branch[branch.length - 1] && p !== branch[branch.length - 2];\n            });\n\n            if (!circeIntersectWithCircles(point, comparingPoints)) {\n              foundPoint = true;\n              makeBranch(\n                { ...point, r: point.r / 1, angle: rad },\n                { ...branch[branch.length - 2], generation: generation + 1 },\n                generation + 1,\n              );\n            }\n          }\n        }\n      }\n    }\n    if (branch.length > 1) {\n      if (beforePoint) {\n        branch = [beforePoint, ...branch];\n      }\n      branches.push(branch);\n    } else {\n      allPoints = allPoints.slice(0, -1);\n    }\n  };\n\n  makeBranch({\n    x,\n    y,\n    r,\n    angle,\n  });\n\n  return branches;\n}\n","var copy = require('vec2-copy')\n\nmodule.exports = function(input, output) {\n    if (!Array.isArray(output))\n        output = []\n\n    if (input.length>0)\n        output.push(copy([0, 0], input[0]))\n    for (var i=0; i<input.length-1; i++) {\n        var p0 = input[i]\n        var p1 = input[i+1]\n        var p0x = p0[0],\n            p0y = p0[1],\n            p1x = p1[0],\n            p1y = p1[1]\n\n        var Q = [ 0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y ]\n        var R = [ 0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y ]\n        output.push(Q)\n        output.push(R)\n    }\n    if (input.length > 1)\n        output.push(copy([0, 0], input[ input.length-1 ]))\n    return output\n}","import { vec3, mat4 } from 'gl-matrix';\nimport { drawLine } from '@/utils/ctx';\nimport { rope } from '@/utils/shape';\n\nconst settings = {\n  dimensions: [1024, 1024],\n  animate: true,\n};\n\nconst sketch = async ({ width, height }) => {\n  const cubeVertices = [\n    [-1, -1, +1],\n    [-1, -1, -1],\n    [+1, -1, -1],\n    [+1, -1, +1],\n    [+1, +1, +1],\n    [+1, +1, -1],\n    [-1, +1, -1],\n    [-1, +1, +1],\n  ];\n\n  const initView = mat4.create();\n\n  const sections = [];\n\n  const maxSectionLength = 100;\n\n  return ({ context, time }) => {\n    context.fillStyle = 'hsla(0, 0%, 98%, .2)';\n    context.fillRect(0, 0, width, height);\n\n    const totalCubes = 5;\n    for (let i = 0; i < totalCubes; i += 1) {\n      const modelView = mat4.clone(initView);\n\n      mat4.rotateX(modelView, modelView, Math.cos(time) + time / 10);\n      mat4.rotateY(modelView, modelView, Math.sin(time));\n      mat4.rotateZ(modelView, modelView, Math.sin(time * i));\n      const sF = Math.cos(time) / 2 + 1.5;\n      mat4.scale(modelView, modelView, [sF, sF, sF]);\n\n      context.fillStyle = `hsl(${time}, 80%, 50%)`;\n\n      const cubeVerticesMorphed = cubeVertices.map(p => {\n        const pT = [];\n        vec3.transformMat4(pT, p, modelView);\n\n        return pT;\n      });\n\n      cubeVerticesMorphed.forEach((p, idx) => {\n        const kId = cubeVertices.length * i + idx;\n        sections[kId] = sections[kId] || [];\n\n        sections[kId].push([p[0] * 100 + width / 2, p[1] * 100 + height / 2]);\n\n        if (sections[kId].length > maxSectionLength) {\n          sections[kId] = sections[kId].slice(1);\n        }\n      });\n    }\n\n    if (sections[0].length > 1) {\n      const sectionRopes = sections.map(section =>\n        rope(section.map((p, idx) => [p[0], p[1], Math.sqrt(section.length - idx) / 2])),\n      );\n\n      sectionRopes.forEach((section, idx) => {\n        context.lineWidth = (Math.cos(idx + time / 2) / 2 + 0.6) * 2;\n        context.strokeStyle = `hsl(${idx * 6 + 150}, 80%, 60%)`;\n        drawLine(context, section);\n      });\n    }\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}