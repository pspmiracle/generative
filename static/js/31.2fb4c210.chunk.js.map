{"version":3,"sources":["utils/sound.js","../node_modules/lodash/get.js","../node_modules/lodash/_baseGet.js","sketches/015_pixel_mania_game/index.js"],"names":["audioCtx","window","AudioContext","webkitAudioContext","playSound","frequency","type","x","volume","o","createOscillator","g","createGain","connect","destination","value","start","gain","exponentialRampToValueAtTime","currentTime","setTimeout","stop","disconnect","baseGet","require","module","exports","object","path","defaultValue","result","undefined","castPath","toKey","index","length","colors","contour","sketch","a","width","height","canvas","cellSize","score","gameOver","gameOverTime","globalTime","highlightLines","matrix","maxY","Math","floor","maxX","reset","y","set","pixelX","pixelY","pride","random","rangeFloor","findNeighbors","cell","expectCells","push","offset","neighborCoord","find","i","neighborCell","get","findAvailableMove","found","foundNeighbors","cleanCells","cells","column","sort","forEach","emptyXes","row","includes","map","idx","b","addEventListener","e","rect","target","getBoundingClientRect","kX","kY","clientX","left","clientY","top","foundCells","dispatchEvent","Event","prevMouseOverX","prevMouseOverY","highlight","line","sameLineIndex","findIndex","hl","filter","_","context","time","fillStyle","fillRect","sqrt","lineWidth","lineCap","strokeStyle","beginPath","moveTo","lineTo","stroke","save","translate","rotate","cos","scale","font","textAlign","shadowBlur","shadowColor","text","fillText","sin","fontSize","restore","settings","dimensions","animate"],"mappings":"2GAAA,sCAAMA,EAAW,IAAKC,OAAOC,cAAgBD,OAAOE,oBAE7C,SAASC,EAAUC,EAAWC,EAAMC,GAAgB,IAAbC,EAAY,uDAAH,EAC/CC,EAAIT,EAASU,mBACbC,EAAIX,EAASY,aACnBH,EAAEI,QAAQF,GACVF,EAAEH,KAAOA,EACTK,EAAEE,QAAQb,EAASc,aACnBL,EAAEJ,UAAUU,MAAQV,EACpBI,EAAEO,QACFL,EAAEM,KAAKF,MAAQP,EACfG,EAAEM,KAAKC,6BAA6B,KAASlB,EAASmB,YAAcZ,GAEpEa,YAAW,WACTX,EAAEY,OACFZ,EAAEa,eACW,KAAXf,EAAI,O,oBChBV,IAAIgB,EAAUC,EAAQ,KAgCtBC,EAAOC,QALP,SAAaC,EAAQC,EAAMC,GACzB,IAAIC,EAAmB,MAAVH,OAAiBI,EAAYR,EAAQI,EAAQC,GAC1D,YAAkBG,IAAXD,EAAuBD,EAAeC,I,oBC7B/C,IAAIE,EAAWR,EAAQ,KACnBS,EAAQT,EAAQ,KAsBpBC,EAAOC,QAZP,SAAiBC,EAAQC,GAMvB,IAHA,IAAIM,EAAQ,EACRC,GAHJP,EAAOI,EAASJ,EAAMD,IAGJQ,OAED,MAAVR,GAAkBO,EAAQC,GAC/BR,EAASA,EAAOM,EAAML,EAAKM,OAE7B,OAAQA,GAASA,GAASC,EAAUR,OAASI,I,0ICVzCK,EAAS,CAAC,UAAW,UAAW,UAAW,UAAW,WAEtDC,EAAU,CACd,CACE,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,CACE,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,CACE,CAAC,EAAG,GACJ,CAAC,EAAG,IAEN,CACE,CAAC,EAAG,GACJ,CAAC,EAAG,KAIFC,EAAM,uCAAG,+DAAAC,EAAA,6DAASC,EAAT,EAASA,MAAOC,EAAhB,EAAgBA,OAAQC,EAAxB,EAAwBA,OAC/BC,EAAmB,IAARH,EAEbI,EAAQ,EACRC,GAAW,EACXC,GAAgB,EAChBC,EAAa,EACbC,EAAiB,GAEfC,EAAS,GACTC,EAAOC,KAAKC,MAAMZ,EAAQG,GAC1BU,EAAOF,KAAKC,MAAMX,EAASE,GAE3BW,EAAQ,WACZV,EAAQ,EACR,IAAK,IAAIW,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAC7B,IAAK,IAAIhD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAC7BiD,IAAIP,EAAQ,CAACM,EAAGhD,GAAI,CAClBA,IACAgD,IACAE,OAAQlD,EAAIoC,EACZe,OAAQH,EAAIZ,EACZgB,MAAOC,IAAOC,WAAW,EAAG,MAM9BC,EAAgB,SAAhBA,EAAiBC,EAAMJ,GAA6B,IAAtBK,EAAqB,uDAAP,GAChDA,EAAYC,KAAKF,GAEjB,IAHuD,iBAGlD,IAAMG,EAAM,KAMTC,EAAgB,CAAE5D,EAAGwD,EAAKxD,EAAI2D,EAAO,GAAIX,EAAGQ,EAAKR,EAAIW,EAAO,IAElE,IAAKF,EAAYI,MAAK,SAAAC,GAAC,OAAIA,EAAE9D,IAAM4D,EAAc5D,GAAK8D,EAAEd,IAAMY,EAAcZ,KAAI,CAC9E,IAAMe,EAAeC,IAAItB,EAAQ,CAACkB,EAAcZ,EAAGY,EAAc5D,IAEjE,GAAI+D,GAAgBA,EAAaX,QAAUA,EAAO,CAChD,IAAMA,EAAQW,EAAaX,MAC3BG,EAAcQ,EAAcX,EAAOK,MAbzC,MAAqB,CACnB,EAAE,EAAG,GACL,CAAC,GAAI,GACL,CAAC,EAAG,GACJ,CAAC,EAAG,IAJN,eAKI,KAcAQ,EAAoB,WAExB,IADA,IAAIC,GAAQ,EACHlB,EAAI,EAAGA,EAAIL,IACduB,EADoBlB,GAAK,EAI7B,IAAK,IAAIhD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAAG,CAChC,IAAMwD,EAAOd,EAAOM,GAAGhD,GACvB,QAAmBwB,IAAfgC,EAAKJ,MAAqB,CAC5B,IAAMe,EAAiB,GAEvB,GADAZ,EAAcC,EAAMA,EAAKJ,MAAOe,GAC5BA,EAAevC,OAAS,EAAG,CAC7BsC,GAAQ,EACR,QAKR,OAAOA,GAGHE,EAAa,SAAAC,GACjB5B,EAAiB,GACjBJ,GAAK,SAAIgC,EAAMzC,OAAU,GAFC,2BAI1B,YAAmByC,EAAnB,+CAA0B,SACnBjB,WAAQ5B,GALW,kFAS1B,IAT0B,eASjBxB,GAEP,IADA,IAAIsE,EAAS,GACJtB,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAC7BsB,EAAOZ,KAAKhB,EAAOM,GAAGhD,KAExBsE,EAASA,EAAOC,MAAK,SAAAf,GAAI,YAAoBhC,IAAfgC,EAAKJ,OAAuB,EAAI,MAEvDoB,SAAQ,SAAChB,EAAMR,GACpBQ,EAAKR,EAAIA,EACTN,EAAOM,GAAGhD,GAAKwD,MATVxD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAAI,EAA1BA,GAcT,IAAMyE,EAAW,GACjB/B,EAAOC,EAAO,GAAG6B,SAAQ,SAAChB,EAAMxD,QACXwB,IAAfgC,EAAKJ,OACPqB,EAASf,KAAK1D,MAGlB,IAAK,IAAIgD,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAAG,CAChC,IAAI0B,EAAMhC,EAAOM,GAEjB0B,GADAA,EAAMA,EAAIH,MAAK,SAAAf,GAAI,OAAKiB,EAASE,SAASnB,EAAKxD,IAAM,EAAI,MAC/C4E,KAAI,SAACpB,EAAMqB,GAEnB,OADArB,EAAKxD,EAAI6E,EACFrB,KAETd,EAAOM,GAAK0B,EAId,IAAK,IAAI1B,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAAG,CAEhC,IADA,IAAM0B,EAAMhC,EAAOM,GACVhD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAAG,CAChC,IAAMwD,EAAOkB,EAAI1E,GACjBwD,EAAKxD,GAAKyE,EAAS7C,OACf4B,EAAKxD,EAAI,IACXwD,EAAKxD,EAAI8C,EAAOU,EAAKxD,GAGzB0C,EAAOM,GAAK0B,EAAIH,MAAK,SAACvC,EAAG8C,GAAJ,OAAU9C,EAAEhC,EAAI8E,EAAE9E,KAGpCiE,MACH3B,GAAW,EACXC,EAAeC,IAInBL,EAAO4C,iBAAiB,SAAS,SAAAC,GAC/B,GAAI1C,EAEEE,EAAaD,EAAe,IAC9BQ,IACAT,GAAW,EACXzC,YAAU,IAAK,OAAQ,SAL3B,CASA,IAAMoF,EAAOD,EAAEE,OAAOC,wBAChBC,EAAKH,EAAKhD,MAAQA,EAClBoD,EAAKJ,EAAK/C,OAASA,EACnBlC,EAAI4C,KAAKC,OAAOmC,EAAEM,QAAUL,EAAKM,OAASnD,EAAWgD,IACrDpC,EAAIJ,KAAKC,OAAOmC,EAAEQ,QAAUP,EAAKQ,MAAQrD,EAAWiD,IAEpD7B,EAAOQ,IAAItB,EAAQ,CAACM,EAAGhD,IAE7B,GAAIwD,QAAuBhC,IAAfgC,EAAKJ,MAAqB,CACpC,IAAMA,EAAQI,EAAKJ,MACbsC,EAAa,GACnBnC,EAAcC,EAAMJ,EAAOsC,GAEvBA,EAAW9D,OAAS,IACtB/B,YAAU,MAA4B,GAApB6F,EAAW9D,OAAa,OAAQ,KAElDwC,EAAWsB,GAEXvD,EAAOwD,cAAc,IAAIC,MAAM,YAAaZ,UAOlD7C,EAAO4C,iBAAiB,aAAa,SAAAC,GACnC,IAAI1C,EAAJ,CAGA,IAAM2C,EAAOD,EAAEE,OAAOC,wBAChBC,EAAKH,EAAKhD,MAAQA,EAClBoD,EAAKJ,EAAK/C,OAASA,EACnBlC,EAAI4C,KAAKC,OAAOmC,EAAEM,QAAUL,EAAKM,OAASnD,EAAWgD,IACrDpC,EAAIJ,KAAKC,OAAOmC,EAAEQ,QAAUP,EAAKQ,MAAQrD,EAAWiD,IAE1D,GAAIQ,IAAmB7F,GAAK8F,IAAmB9C,EAA/C,CAIA6C,EAAiB7F,EACjB8F,EAAiB9C,EAEjBP,EAAiB,GAEjB,IAAK,IAAIO,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAC7B,IAAK,IAAIhD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAC7B0C,EAAOM,GAAGhD,GAAG+F,WAAY,EAI7B,IAAMvC,EAAOQ,IAAItB,EAAQ,CAACM,EAAGhD,IAE7B,GAAIwD,QAAuBhC,IAAfgC,EAAKJ,MAAqB,CACpC,IAAMA,EAAQI,EAAKJ,MACbsC,EAAa,GACnBnC,EAAcC,EAAMJ,EAAOsC,GAEvBA,EAAW9D,OAAS,GACtB8D,EAAWlB,SAAQ,SAAAhB,GACjBA,EAAKuC,WAAY,KAKvB,IAAK,IAAI/C,EAAI,EAAGA,EAAIL,EAAMK,GAAK,EAC7B,IAAK,IAAIhD,EAAI,EAAGA,EAAI8C,EAAM9C,GAAK,EAAG,CAChC,IAAMwD,EAAOd,EAAOM,GAAGhD,GACvB,GAAIwD,EAAKuC,UAAW,CAAC,IAAD,uBAClB,IADkB,IAClB,EADkB,0CACNjB,EADM,KACHE,EADG,KAEVgB,EAAO,CACX,CAACxC,EAAKxD,EAAI8E,EAAE,GAAItB,EAAKR,EAAI8B,EAAE,IAC3B,CAACtB,EAAKxD,EAAIgF,EAAE,GAAIxB,EAAKR,EAAIgC,EAAE,KAEvBiB,EAAgBxD,EAAeyD,WAAU,SAAAC,GAC7C,OACEA,EAAG,GAAG,KAAOH,EAAK,GAAG,IAAMG,EAAG,GAAG,KAAOH,EAAK,GAAG,IAAMG,EAAG,GAAG,KAAOH,EAAK,GAAG,IAAMG,EAAG,GAAG,KAAOH,EAAK,GAAG,OAGnF,IAAnBC,EACFxD,EAAeiB,KAAKsC,GAEpBvD,EAAiBA,EAAe2D,QAAO,SAACC,EAAGxB,GAAJ,OAAYA,IAAQoB,MAb/D,EAAqBnE,EAArB,+CAA+B,IADb,0FA9Mb,mBAoON,YAAuC,IAApCwE,EAAmC,EAAnCA,QAASrE,EAA0B,EAA1BA,MAAOC,EAAmB,EAAnBA,OAAQqE,EAAW,EAAXA,KAChC/D,EAAa+D,EACbD,EAAQE,UAAY,sBACpBF,EAAQG,SAAS,EAAG,EAAGxE,EAAOC,GAE9B,IAAK,IAAIc,EAAI,EAAGA,EAAIN,EAAOd,OAAQoB,GAAK,EAEtC,IADA,IAAM0B,EAAMhC,EAAOM,GACVhD,EAAI,EAAGA,EAAI0E,EAAI9C,OAAQ5B,GAAK,EAAG,CACtC,IAAMwD,EAAOkB,EAAI1E,GAGbwD,EAAKL,OAASK,EAAKR,EAAIZ,EACzBoB,EAAKL,QAAUP,KAAK8D,KAAKlD,EAAKR,EAAIZ,EAAWoB,EAAKL,QAElDK,EAAKL,OAASK,EAAKR,EAAIZ,EAIrBoB,EAAKN,OAASM,EAAKxD,EAAIoC,EACzBoB,EAAKN,QAAUN,KAAK8D,KAAKlD,EAAKN,OAASM,EAAKxD,EAAIoC,GAEhDoB,EAAKN,OAASM,EAAKxD,EAAIoC,EAIXP,EAAO2B,EAAKJ,SAExBkD,EAAQE,UAAY3E,EAAO2B,EAAKJ,OAChCkD,EAAQG,SAASjD,EAAKN,OAAQM,EAAKL,OAAQf,EAAW,GAAKA,EAAW,IAgB5E,GAXAkE,EAAQK,UAAY,IACpBL,EAAQM,QAAU,OAClBN,EAAQO,YAAc,qBAEtBpE,EAAe+B,SAAQ,SAAA2B,GACrBG,EAAQQ,YACRR,EAAQS,OAAOZ,EAAG,GAAG,GAAK/D,EAAU+D,EAAG,GAAG,GAAK/D,GAC/CkE,EAAQU,OAAOb,EAAG,GAAG,GAAK/D,EAAU+D,EAAG,GAAG,GAAK/D,GAC/CkE,EAAQW,YAGN3E,EAAU,CACZgE,EAAQY,OACRZ,EAAQa,UAAUlF,EAAQ,EAAGC,EAAS,GACtCoE,EAAQc,OAAOxE,KAAKyE,IAAW,EAAPd,GAAY,IACpCD,EAAQgB,MAAM1E,KAAKyE,IAAW,EAAPd,GAAY,EAAI,EAAG3D,KAAKyE,IAAW,EAAPd,GAAY,EAAI,GAEnED,EAAQiB,KAAR,eADiB,GACjB,YACAjB,EAAQkB,UAAY,SACpBlB,EAAQmB,WAAa,EACrBnB,EAAQoB,YAAc,kBAEtB,IAAMC,EAAiB,IAAVtF,EAAc,cAAgB,aAC3CiE,EAAQE,UAAY,oBACpBF,EAAQsB,SAASD,EAA2B,EAArB/E,KAAKyE,IAAW,EAAPd,GAAe,GAE/CD,EAAQE,UAAY,sBACpBF,EAAQsB,SAASD,EAA2B,EAArB/E,KAAKiF,IAAW,EAAPtB,GAAe,GAE/CD,EAAQE,UAAY,mBACpBF,EAAQsB,SAASD,EAAM,EAAG,GAE1BrB,EAAQE,UAAY,oBAEhBnE,GACFiE,EAAQiB,KAAR,eAAuBO,GAAvB,YACAxB,EAAQsB,SAAR,iBAA2BvF,GAAS,EAAGyF,MAEvCxB,EAAQiB,KAAR,eAAuBO,GAAvB,YACAxB,EAAQsB,SAAR,kBAAoC,EAAGE,KAGzCxB,EAAQyB,cA/SC,4CAAH,sDAoTG,WACbhG,SACAiG,SAhVe,CACfC,WAAY,CAAC,IAAK,KAClBC,SAAS","file":"static/js/31.2fb4c210.chunk.js","sourcesContent":["const audioCtx = new (window.AudioContext || window.webkitAudioContext)();\n\nexport function playSound(frequency, type, x, volume = 1) {\n  const o = audioCtx.createOscillator();\n  const g = audioCtx.createGain();\n  o.connect(g);\n  o.type = type;\n  g.connect(audioCtx.destination);\n  o.frequency.value = frequency;\n  o.start();\n  g.gain.value = volume;\n  g.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + x);\n\n  setTimeout(() => {\n    o.stop();\n    o.disconnect();\n  }, (x + 0.5) * 1000);\n}\n","var baseGet = require('./_baseGet');\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n","var castPath = require('./_castPath'),\n    toKey = require('./_toKey');\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = castPath(path, object);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\nmodule.exports = baseGet;\n","import random from 'canvas-sketch-util/random';\nimport set from 'lodash/set';\nimport get from 'lodash/get';\nimport { playSound } from '@/utils/sound';\n\nconst settings = {\n  dimensions: [600, 600],\n  animate: true,\n};\n\nconst colors = ['#556270', '#4ecdc4', '#c7f464', '#ff6b6b', '#c44d58'];\n\nconst contour = [\n  [\n    [0, 0],\n    [1, 0],\n  ],\n  [\n    [1, 0],\n    [1, 1],\n  ],\n  [\n    [0, 0],\n    [0, 1],\n  ],\n  [\n    [0, 1],\n    [1, 1],\n  ],\n];\n\nconst sketch = async ({ width, height, canvas }) => {\n  const cellSize = width * 0.05;\n\n  let score = 0;\n  let gameOver = true;\n  let gameOverTime = -1;\n  let globalTime = 0;\n  let highlightLines = [];\n\n  const matrix = [];\n  const maxY = Math.floor(width / cellSize);\n  const maxX = Math.floor(height / cellSize);\n\n  const reset = () => {\n    score = 0;\n    for (let y = 0; y < maxY; y += 1) {\n      for (let x = 0; x < maxX; x += 1) {\n        set(matrix, [y, x], {\n          x,\n          y,\n          pixelX: x * cellSize,\n          pixelY: y * cellSize,\n          pride: random.rangeFloor(0, 4),\n        });\n      }\n    }\n  };\n\n  const findNeighbors = (cell, pride, expectCells = []) => {\n    expectCells.push(cell);\n\n    for (const offset of [\n      [-1, 0],\n      [0, -1],\n      [1, 0],\n      [0, 1],\n    ]) {\n      const neighborCoord = { x: cell.x + offset[0], y: cell.y + offset[1] };\n\n      if (!expectCells.find(i => i.x === neighborCoord.x && i.y === neighborCoord.y)) {\n        const neighborCell = get(matrix, [neighborCoord.y, neighborCoord.x]);\n\n        if (neighborCell && neighborCell.pride === pride) {\n          const pride = neighborCell.pride;\n          findNeighbors(neighborCell, pride, expectCells);\n        }\n      }\n    }\n  };\n\n  const findAvailableMove = () => {\n    let found = false;\n    for (let y = 0; y < maxY; y += 1) {\n      if (found) {\n        break;\n      }\n      for (let x = 0; x < maxX; x += 1) {\n        const cell = matrix[y][x];\n        if (cell.pride !== undefined) {\n          const foundNeighbors = [];\n          findNeighbors(cell, cell.pride, foundNeighbors);\n          if (foundNeighbors.length > 1) {\n            found = true;\n            break;\n          }\n        }\n      }\n    }\n    return found;\n  };\n\n  const cleanCells = cells => {\n    highlightLines = [];\n    score += cells.length ** 2;\n\n    for (const cell of cells) {\n      cell.pride = undefined;\n    }\n\n    // Compress Y\n    for (let x = 0; x < maxX; x += 1) {\n      let column = [];\n      for (let y = 0; y < maxY; y += 1) {\n        column.push(matrix[y][x]);\n      }\n      column = column.sort(cell => (cell.pride === undefined ? -1 : 1));\n\n      column.forEach((cell, y) => {\n        cell.y = y;\n        matrix[y][x] = cell;\n      });\n    }\n\n    // Compress X (by checking last row only)\n    const emptyXes = [];\n    matrix[maxY - 1].forEach((cell, x) => {\n      if (cell.pride === undefined) {\n        emptyXes.push(x);\n      }\n    });\n    for (let y = 0; y < maxY; y += 1) {\n      let row = matrix[y];\n      row = row.sort(cell => (emptyXes.includes(cell.x) ? -1 : 1));\n      row = row.map((cell, idx) => {\n        cell.x = idx;\n        return cell;\n      });\n      matrix[y] = row;\n    }\n\n    // Move to left side\n    for (let y = 0; y < maxY; y += 1) {\n      const row = matrix[y];\n      for (let x = 0; x < maxX; x += 1) {\n        const cell = row[x];\n        cell.x -= emptyXes.length;\n        if (cell.x < 0) {\n          cell.x = maxX + cell.x;\n        }\n      }\n      matrix[y] = row.sort((a, b) => a.x - b.x);\n    }\n\n    if (!findAvailableMove()) {\n      gameOver = true;\n      gameOverTime = globalTime;\n    }\n  };\n\n  canvas.addEventListener('click', e => {\n    if (gameOver) {\n      // Delay to prevent miss click\n      if (globalTime - gameOverTime > 1) {\n        reset();\n        gameOver = false;\n        playSound(200, 'sine', 0.9);\n      }\n      return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const kX = rect.width / width;\n    const kY = rect.height / height;\n    const x = Math.floor((e.clientX - rect.left) / (cellSize * kX));\n    const y = Math.floor((e.clientY - rect.top) / (cellSize * kY));\n\n    const cell = get(matrix, [y, x]);\n\n    if (cell && cell.pride !== undefined) {\n      const pride = cell.pride;\n      const foundCells = [];\n      findNeighbors(cell, pride, foundCells);\n\n      if (foundCells.length > 1) {\n        playSound(349.2 + foundCells.length * 50, 'sine', 0.12);\n\n        cleanCells(foundCells);\n\n        canvas.dispatchEvent(new Event('mousemove', e));\n      }\n    }\n  });\n\n  let prevMouseOverX;\n  let prevMouseOverY;\n  canvas.addEventListener('mousemove', e => {\n    if (gameOver) {\n      return;\n    }\n    const rect = e.target.getBoundingClientRect();\n    const kX = rect.width / width;\n    const kY = rect.height / height;\n    const x = Math.floor((e.clientX - rect.left) / (cellSize * kX));\n    const y = Math.floor((e.clientY - rect.top) / (cellSize * kY));\n\n    if (prevMouseOverX === x && prevMouseOverY === y) {\n      return;\n    }\n\n    prevMouseOverX = x;\n    prevMouseOverY = y;\n\n    highlightLines = [];\n    // Clean highlight\n    for (let y = 0; y < maxY; y += 1) {\n      for (let x = 0; x < maxX; x += 1) {\n        matrix[y][x].highlight = false;\n      }\n    }\n\n    const cell = get(matrix, [y, x]);\n\n    if (cell && cell.pride !== undefined) {\n      const pride = cell.pride;\n      const foundCells = [];\n      findNeighbors(cell, pride, foundCells);\n\n      if (foundCells.length > 1) {\n        foundCells.forEach(cell => {\n          cell.highlight = true;\n        });\n      }\n    }\n\n    for (let y = 0; y < maxY; y += 1) {\n      for (let x = 0; x < maxX; x += 1) {\n        const cell = matrix[y][x];\n        if (cell.highlight) {\n          for (const [b, e] of contour) {\n            const line = [\n              [cell.x + b[0], cell.y + b[1]],\n              [cell.x + e[0], cell.y + e[1]],\n            ];\n            const sameLineIndex = highlightLines.findIndex(hl => {\n              return (\n                hl[0][0] === line[0][0] && hl[0][1] === line[0][1] && hl[1][0] === line[1][0] && hl[1][1] === line[1][1]\n              );\n            });\n            if (sameLineIndex === -1) {\n              highlightLines.push(line);\n            } else {\n              highlightLines = highlightLines.filter((_, idx) => idx !== sameLineIndex);\n            }\n          }\n        }\n      }\n    }\n  });\n\n  return ({ context, width, height, time }) => {\n    globalTime = time;\n    context.fillStyle = 'hsla(0, 0%, 98%, 1)';\n    context.fillRect(0, 0, width, height);\n\n    for (let y = 0; y < matrix.length; y += 1) {\n      const row = matrix[y];\n      for (let x = 0; x < row.length; x += 1) {\n        const cell = row[x];\n\n        // Move cells Y\n        if (cell.pixelY < cell.y * cellSize) {\n          cell.pixelY += Math.sqrt(cell.y * cellSize - cell.pixelY);\n        } else {\n          cell.pixelY = cell.y * cellSize;\n        }\n\n        // Move cells X\n        if (cell.pixelX > cell.x * cellSize) {\n          cell.pixelX -= Math.sqrt(cell.pixelX - cell.x * cellSize);\n        } else {\n          cell.pixelX = cell.x * cellSize;\n        }\n\n        // Draw cells\n        const color = colors[cell.pride];\n        if (color) {\n          context.fillStyle = colors[cell.pride];\n          context.fillRect(cell.pixelX, cell.pixelY, cellSize + 0.5, cellSize + 1);\n        }\n      }\n    }\n\n    context.lineWidth = 1.5;\n    context.lineCap = 'butt';\n    context.strokeStyle = 'hsla(0,0%,0%, 0.5)';\n\n    highlightLines.forEach(hl => {\n      context.beginPath();\n      context.moveTo(hl[0][0] * cellSize, hl[0][1] * cellSize);\n      context.lineTo(hl[1][0] * cellSize, hl[1][1] * cellSize);\n      context.stroke();\n    });\n\n    if (gameOver) {\n      context.save();\n      context.translate(width / 2, height / 2);\n      context.rotate(Math.cos(time * 2) / 10);\n      context.scale(Math.cos(time * 4) / 8 + 1, Math.cos(time * 4) / 8 + 1);\n      const fontSize = 80;\n      context.font = `bold ${fontSize}px Arial`;\n      context.textAlign = 'center';\n      context.shadowBlur = 6;\n      context.shadowColor = 'hsl(0, 0%, 10%)';\n\n      const text = score === 0 ? 'Pixel Mania' : 'Game Over!';\n      context.fillStyle = 'rgba(255,0,0,0.4)';\n      context.fillText(text, Math.cos(time * 4) * 5, 0);\n\n      context.fillStyle = 'rgba(0,255,255,0.4)';\n      context.fillText(text, Math.sin(time * 4) * 5, 0);\n\n      context.fillStyle = 'hsl(0, 0%, 100%)';\n      context.fillText(text, 0, 0);\n\n      context.fillStyle = 'hsl(0, 0%, 97.5%)';\n\n      if (score) {\n        context.font = `bold ${fontSize - 20}px Arial`;\n        context.fillText(`Score: ${score}`, 0, fontSize - 10);\n      } else {\n        context.font = `bold ${fontSize - 30}px Arial`;\n        context.fillText(`Click to start!`, 0, fontSize - 20);\n      }\n\n      context.restore();\n    }\n  };\n};\n\nexport default {\n  sketch,\n  settings,\n};\n"],"sourceRoot":""}