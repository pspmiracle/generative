{"version":3,"sources":["unreleased/black_hole/shaders/vert.glsl","unreleased/black_hole/shaders/frag.glsl","unreleased/black_hole/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","Black","camera","Math","PI","Zero","maxZ","fov","attachControl","ShadersStore","customVertexShader","customFragmentShader","plane","CreateGround","planeMaterial","vertex","fragment","attributes","uniforms","material","backFaceCulling","alphaMode","ALPHA_ADD","setVector2","render","time","setFloat","aRatio","getEngine","getAspectRatio","alpha","sin","resize","pixelRatio","unload","dispose","settings","animate","context"],"mappings":"mHAAA,OAAe,sY,iCCAf,OAAe,s5C,+FCSTA,EAAM,uCAAG,uCAAAC,EAAA,6DAASC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAGLC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAaJ,SAAeK,OAC5BC,EAAS,IAAIN,kBAAwB,UAAWO,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAG,IAAKR,UAAgBS,OAAQN,IACtGO,KAAO,IACdJ,EAAOK,IAAM,IACbL,EAAOM,cAAchB,GAAQ,GAE7BI,SAAea,aAAaC,mBAAqBA,UACjDd,SAAea,aAAaE,qBAAuBA,UAE7CC,EAAQ,IAAIhB,OAAaiB,aAAa,QAAS,IAAM,IAAM,IAAKd,GAAO,GAEvEe,EAAgB,IAAIlB,iBACxB,gBACAG,EACA,CACEgB,OAAQ,SACRC,SAAU,UAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,iBAG7EN,EAAMO,SAAWL,EACjBA,EAAcM,iBAAkB,EAChCN,EAAcO,UAAYzB,SAAe0B,UAEzCR,EAAcS,WAAW,cAAe,IAAI3B,UAAgB,EAAG,IAElD,IApCA,kBAsCN,CACL4B,OADK,YACa,IAATC,EAAQ,EAARA,KACPX,EAAcY,SAAS,QAASD,GAChC,IAAME,EAAS5B,EAAM6B,YAAYC,eAAe3B,GAChDY,EAAcS,WAAW,cAAe,IAAI3B,UAAgB+B,EAAQ,IACpEzB,EAAO4B,OAAgB,KAAPL,EAChBvB,EAAOK,IARE,IAQkC,KAAvBJ,KAAK4B,IAAW,GAAPN,GAE7B1B,EAAMyB,UAERQ,OAVK,YAUiC,EAA7BC,WAA6B,EAAjBxC,MAAiB,EAAVC,OAC1BC,EAAOqC,UAETE,OAbK,WAcHvC,EAAOwC,aApDE,4CAAH,sDAyDG,WAAE7C,SAAQ8C,SA9DR,CACfC,SAAS,EACTC,QAAS","file":"static/js/47.e1070980.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\n\\nuniform mat4 worldViewProjection;\\nuniform float time;\\n\\nvarying vec2 vUV;\\n\\nvoid main() {\\n  vec4 p = vec4( position, 1. );\\n  float l = length(position.xz);\\n\\n  p.y += sqrt(sqrt(sqrt(l*1000.)*50.)*5000.);\\n  p.y -= 750.;\\n  vUV = uv;\\n  gl_Position = worldViewProjection * p;\\n}\\n\";","export default \"#define GLSLIFY 1\\nuniform float iTime;\\nuniform vec2 iResolution;\\n\\nvarying vec2 vUV;\\n\\n#define SIZE 500.\\n#define LAYERS 10.\\n\\n#define SF SIZE/min(iResolution.x,iResolution.y)*1.5\\n#define SS(l,s) smoothstep(SF,-SF,l-s)\\n\\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453)\\n\\nmat2 rot (float a){\\n  float ca = cos(a);\\n  float sa = sin(a);\\n  return mat2(ca,-sa,sa,ca);\\n}\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n  vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\\n  vec2 ouv = fragCoord/iResolution.xy;\\n\\n  vec3 col = vec3(0.);\\n  for(float i=0.;i<LAYERS;i++){\\n    vec2 iuv = uv;\\n    iuv *= rot(iTime*(.5 + i*.1) );\\n    // iuv *= rot(1.*(.5 + i*.1) );\\n\\n    vec2 guv = iuv*SIZE;\\n    vec2 gid = floor(guv);\\n\\n    float iF = rand1(i);\\n\\n    vec2 offSet = vec2(rand1(gid.x*iF + gid.y*2000.*iF), rand1(gid.y*iF + gid.x*1000.*iF))*.5 -.25;\\n\\nguv = fract(guv) - .5 - offSet;\\n\\nfloat l = length(guv);\\n\\nfloat pSize = rand1(gid.x*iF + gid.y*7000.*iF)*.2;\\nfloat showWeight = sqrt(length(uv))*.5;\\nfloat showFactor = rand1(gid.x*100.*iF+gid.y*200.*iF) > showWeight ? 1. : 0.;\\nfloat im = smoothstep(pSize, pSize-iF, l) * showFactor;\\n\\ncol += fract(rand1(gid.x*iF + gid.y*200.*iF)) * im;\\n}\\n\\nfragColor = vec4(col,1.);\\n}\\n\\nvoid main()\\n{\\n  mainImage(gl_FragColor, vUV * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport customVertexShader from './shaders/vert.glsl';\nimport customFragmentShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = BABYLON.Color3.Black;\n  const camera = new BABYLON.ArcRotateCamera('Camera', -Math.PI / 2, Math.PI / 3, 400, BABYLON.Vector3.Zero(), scene);\n  camera.maxZ = 3000;\n  camera.fov = 1.5;\n  camera.attachControl(canvas, true);\n\n  BABYLON.Effect.ShadersStore.customVertexShader = customVertexShader;\n  BABYLON.Effect.ShadersStore.customFragmentShader = customFragmentShader;\n\n  const plane = new BABYLON.Mesh.CreateGround('plane', 5000, 5000, 500, scene, false);\n\n  const planeMaterial = new BABYLON.ShaderMaterial(\n    'planeMaterial',\n    scene,\n    {\n      vertex: 'custom',\n      fragment: 'custom',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'iTime', 'iResolution'],\n    },\n  );\n  plane.material = planeMaterial;\n  planeMaterial.backFaceCulling = false;\n  planeMaterial.alphaMode = BABYLON.Engine.ALPHA_ADD;\n\n  planeMaterial.setVector2('iResolution', new BABYLON.Vector2(1, 1));\n\n  const oFov = 1.5;\n\n  return {\n    render({ time }) {\n      planeMaterial.setFloat('iTime', time);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      planeMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n      camera.alpha += time * 0.000001;\n      camera.fov = oFov + Math.sin(time * 0.5) * 0.125;\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}