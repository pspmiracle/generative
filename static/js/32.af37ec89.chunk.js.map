{"version":3,"sources":["sketches/021_snow_forest/shaders/vert.glsl","sketches/021_snow_forest/shaders/frag.glsl","sketches/021_snow_forest/index.js"],"names":["THREE","require","random","global","font","randomInstance","createRandom","setSeed","createTreeGeometry","treeGeometry","CylinderGeometry","vertices","forEach","vertex","y","height","randomFactor","level","Math","round","x","value","z","rotateZ","PI","computeVertexNormals","sketch","context","renderer","WebGLRenderer","canvas","setClearColor","shadowMap","enabled","type","PCFSoftShadowMap","camera","PerspectiveCamera","position","set","lookAt","Vector3","controls","OrbitControls","minDistance","maxDistance","scene","Scene","fog","Fog","lightMain","HemisphereLight","add","lightDir1","DirectionalLight","castShadow","lightDir2","light","shadow","mapSize","width","near","far","top","bottom","left","right","geometry","PlaneGeometry","noise2D","plane","Mesh","material","MeshPhongMaterial","side","DoubleSide","emissive","setHex","emissiveIntensity","color","createGroundSnowMaterial","rotation","receiveShadow","greenMaterial","MeshLambertMaterial","setHSL","createGreenMaterial","snowMaterial","createTreeSnowMaterial","i","posX","range","posY","sqrt","mesh","scale","wideScale","snowMesh","particles","Geometry","map","v","push","shaderPoint","ShaderLib","points","uniforms","iTime","pSize","camPosition","Uniform","pMaterial","ShaderMaterial","transparent","depthWrite","blending","AdditiveBlending","fragmentShader","vertexShader","particleSystem","Points","sortParticles","textMaterial","opacity","shininess","createTextMaterial","TextGeometry","Font","size","curveSegments","bevelEnabled","bevelThickness","bevelSize","bevelOffset","bevelSegments","textMesh","rotateY","rotateX","resize","pixelRatio","viewportWidth","viewportHeight","setPixelRatio","setSize","aspect","updateProjectionMatrix","render","time","dimensions","min","max","update","unload","dispose","settings","animate"],"mappings":"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","file":"static/js/32.af37ec89.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvarying vec2 vUv;\\nvarying vec3 vpos;\\nvarying float hp;\\nvarying float hp2;\\nvarying float hp3;\\n\\nuniform float iTime;\\nuniform float pSize;\\nuniform vec3 camPosition;\\n\\nfloat hash(vec3 p)// replace this by something better\\n{\\n  p  = fract(p*0.3183099+.1);\\n  p *= 17.0;\\n  return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n\\n  hp = hash(position); // Рандомный фактор для точки по позиции\\n  hp2 = hash(position*3.3); // Дополнительный рандомный фактор\\n  hp3 = hash(position*6.6); // Еще один рандомный фактор\\n\\n  float t = iTime*.5 + hp; // Замедляем время и прибавляем рандомный фактор - у этой точки будет \\\"своё\\\" время\\n\\n  vpos = position;\\n\\n  // индивидульный рандомнеый vec3 для точки для определения движения точки\\n  vec3 npp = vec3(hash(position), hash(position*10.), hash(position*20.))*2.;\\n\\n  // Фактор смещения через симплексный шум\\n  float nF = snoise((npp + vec3(iTime*.525)) * 1.) * (.25 + fract(t))*.5;\\n\\n  // Дивгаем точки\\n  vpos.y -= (vpos.y * fract(t)*2. );\\n\\n  // Добавляем фактор плавающего смещения\\n  vpos.xyz += nF*2.;\\n\\n  gl_PointSize = pSize*25. / length(camPosition - vpos);\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( vpos, 1.0 );\\n}\\n\";","export default \"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec3 vpos;\\nvarying float hp;\\nvarying float hp2;\\nvarying float hp3;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\nuniform float pSize;\\n\\nuniform mat3 uvTransform;\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\\n  vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  float t = iTime*.5 + hp; // Делаем время для точки такое же как в vertexShader\\n\\n  float g = length(uv) * pSize;\\n  float gx = clamp(.05 / smoothstep(.0, pSize, g), 0., 1.);\\n\\n  // Прозрачность считаем от hp3 чтоб все точки были с разной яркостью\\n  fragColor = vec4(vec3(gx) / g, hp3/(pSize*.25));\\n}\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import vertexShader from './shaders/vert.glsl';\nimport fragmentShader from './shaders/frag.glsl';\n\nconst THREE = require('three');\nconst random = require('canvas-sketch-util').random;\n\nglobal.THREE = THREE;\n\nrequire('three/examples/js/controls/OrbitControls');\n\nconst font = require('./font.json');\n\nconst randomInstance = random.createRandom();\nrandomInstance.setSeed('996048');\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nfunction createGreenMaterial() {\n  const material = new THREE.MeshLambertMaterial({\n    side: THREE.DoubleSide,\n  });\n\n  // material.wireframe = true;\n\n  const hue = 0.4;\n  const saturation = 1;\n  const luminance = 0.5;\n  material.color.setHSL(hue, saturation, luminance);\n\n  return material;\n}\n\nfunction createGroundSnowMaterial() {\n  const material = new THREE.MeshPhongMaterial({\n    side: THREE.DoubleSide,\n  });\n\n  material.emissive.setHex(0xeeeeee);\n  material.emissiveIntensity = 0.125;\n\n  material.color.setHex(0xffffff);\n\n  return material;\n}\n\nfunction createTreeSnowMaterial() {\n  const material = new THREE.MeshPhongMaterial({});\n  material.emissive.setHex(0xffffff);\n  material.emissiveIntensity = 0.5;\n\n  material.color.setHex(0xffffff);\n\n  return material;\n}\n\nfunction createTextMaterial() {\n  const material = new THREE.MeshPhongMaterial({\n    opacity: 0.75,\n    transparent: true,\n    shininess: 100,\n  });\n  material.emissive.setHSL(0.5, 0.5, 0.2);\n  material.emissiveIntensity = 0.5;\n\n  material.color.setHex(0xffffff);\n\n  return material;\n}\n\nfunction createTreeGeometry() {\n  const height = 1;\n  const levels = 10;\n\n  const treeGeometry = new THREE.CylinderGeometry(0.4, 0.0, height, 20, levels);\n  treeGeometry.vertices.forEach(vertex => {\n    vertex.y += height * 0.5;\n    const randomFactor = vertex.y * 0.1;\n\n    vertex.level = Math.round(vertex.y * 10);\n\n    vertex.x += randomInstance.value() * randomFactor;\n    vertex.z += randomInstance.value() * randomFactor;\n  });\n\n  treeGeometry.vertices.forEach(vertex => {\n    if (vertex.level % 2 === 0) {\n      vertex.x *= 0.1;\n      vertex.z *= 0.1;\n      vertex.y -= 0.2;\n    } else {\n      if (vertex.level) {\n        vertex.y += (randomInstance.value() - 0.5) * 0.1;\n      }\n    }\n\n    // Пилим верхушки\n    if (vertex.level <= 2) {\n      vertex.x *= 0.0;\n      vertex.z *= 0.0;\n    }\n  });\n  treeGeometry.rotateZ(Math.PI);\n\n  treeGeometry.computeVertexNormals();\n\n  return treeGeometry;\n}\n\nconst sketch = ({ context }) => {\n  // Create a renderer\n  const renderer = new THREE.WebGLRenderer({\n    canvas: context.canvas,\n  });\n\n  // renderer.setClearColor('hsl(200, 50%, 20%)', 1);\n  renderer.setClearColor('#fafafa', 1);\n  renderer.shadowMap.enabled = true;\n  renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap\n\n  const camera = new THREE.PerspectiveCamera(25, 1, 0.01, 100);\n  camera.position.set(10, 5, -18);\n\n  camera.lookAt(new THREE.Vector3());\n  const controls = new THREE.OrbitControls(camera, context.canvas);\n  controls.minDistance = 10;\n  controls.maxDistance = 40;\n\n  const scene = new THREE.Scene();\n\n  scene.fog = new THREE.Fog(0xffffff, 20, 50);\n\n  // ---------------------------------------------\n  // Свет\n  // ---------------------------------------------\n\n  const whiteColor = 0xffffff;\n  const lightMain = new THREE.HemisphereLight(whiteColor, 0xffffff, 0.2);\n  scene.add(lightMain);\n\n  const lightDir1 = new THREE.DirectionalLight(whiteColor, 0.251);\n  lightDir1.position.set(3, 10, -10);\n  lightDir1.castShadow = true;\n  scene.add(lightDir1);\n\n  const lightDir2 = new THREE.DirectionalLight(whiteColor, 0.51);\n  lightDir2.position.set(3, 20, -10);\n  lightDir2.castShadow = true;\n  scene.add(lightDir2);\n\n  [lightDir1, lightDir2].forEach(light => {\n    // Set up shadow properties for the light\n    light.shadow.mapSize.width = 512; // default\n    light.shadow.mapSize.height = 512; // default\n    light.shadow.camera.near = 0.5; // default\n    light.shadow.camera.far = 500; // default\n\n    const side = 15;\n    light.shadow.camera.top = side;\n    light.shadow.camera.bottom = -side;\n    light.shadow.camera.left = side;\n    light.shadow.camera.right = -side;\n\n    // const shadowHelper = new THREE.CameraHelper(light.shadow.camera);\n    // scene.add(shadowHelper);\n  });\n\n  // ---------------------------------------------\n  // Земля\n  // ---------------------------------------------\n  {\n    const geometry = new THREE.PlaneGeometry(60, 60, 100, 100);\n    geometry.vertices.forEach(vertex => {\n      vertex.z += randomInstance.noise2D(vertex.x * 0.1, vertex.y * 0.1) * 0.5;\n    });\n    const plane = new THREE.Mesh(geometry, createGroundSnowMaterial());\n    plane.rotation.x = +Math.PI * 0.5;\n    plane.position.y = +0.5;\n\n    plane.receiveShadow = true;\n\n    scene.add(plane);\n  }\n\n  // ---------------------------------------------\n  // Деревья\n  // ---------------------------------------------\n\n  {\n    const greenMaterial = createGreenMaterial();\n    const snowMaterial = createTreeSnowMaterial();\n\n    for (let i = 0; i < 500; i += 1) {\n      const posX = random.range(-15, 15);\n      const posY = random.range(-15, 15);\n\n      const len = Math.sqrt(posX * posX + posY * posY);\n      if (len > 15) {\n        continue;\n      }\n\n      // Где буквы - там без ёлок\n      if (posX < 6 && posX > -6 && posY < 2 && posY > -1) {\n        continue;\n      }\n\n      const height = 1;\n      const mesh = new THREE.Mesh(createTreeGeometry(), greenMaterial);\n      mesh.position.y += height * 0.5;\n\n      mesh.position.x = posX;\n      mesh.position.z = posY;\n\n      mesh.position.y -= randomInstance.noise2D(mesh.position.x * 0.1, mesh.position.z * 0.1) * 0.5;\n\n      // Высота\n      mesh.scale.y = 1 + randomInstance.value();\n      mesh.position.y += mesh.scale.y;\n\n      // Ширина\n      const wideScale = 1 + randomInstance.value();\n      mesh.scale.x = wideScale;\n      mesh.scale.z = wideScale;\n\n      mesh.castShadow = true;\n      mesh.receiveShadow = true;\n\n      const snowMesh = new THREE.Mesh(createTreeGeometry(), snowMaterial);\n      snowMesh.position.x = mesh.position.x;\n      snowMesh.position.y = mesh.position.y + 0.1;\n      snowMesh.position.z = mesh.position.z;\n\n      snowMesh.scale.x = mesh.scale.x;\n      snowMesh.scale.y = mesh.scale.y;\n      snowMesh.scale.z = mesh.scale.z;\n\n      snowMesh.castShadow = true;\n      snowMesh.receiveShadow = true;\n\n      scene.add(mesh);\n      scene.add(snowMesh);\n    }\n  }\n\n  // -------------------------\n  // Снежок\n  // -------------------------\n\n  // const particles = new THREE.PlaneGeometry(40, 40, 50, 50);\n  const particles = new THREE.Geometry(40, 40, 50, 50);\n  // particles.rotateX(Math.PI * 0.5);\n  particles.vertices = particles.vertices.map(v => {\n    v.x += (randomInstance.value() - 0.5) * 0.05;\n    v.y += (randomInstance.value() - 0.5) * 4 + 6;\n    v.z += (randomInstance.value() - 0.5) * 0.05;\n    return v;\n  });\n\n  for (let i = 0; i < 50000; i += 1) {\n    particles.vertices.push(\n      new THREE.Vector3(\n        (randomInstance.value() - 0.5) * 40,\n        (randomInstance.value() - 0.5) * 4 + 6,\n        (randomInstance.value() - 0.5) * 40,\n      ),\n    );\n  }\n\n  const shaderPoint = THREE.ShaderLib.points;\n  const uniforms = {\n    ...shaderPoint.uniforms,\n    iTime: { value: 0 },\n    pSize: { value: 10 },\n    camPosition: new THREE.Uniform(camera.position),\n  };\n\n  const pMaterial = new THREE.ShaderMaterial({\n    uniforms,\n    transparent: true,\n    depthWrite: false,\n\n    blending: THREE.AdditiveBlending,\n\n    fragmentShader,\n    vertexShader,\n  });\n\n  const particleSystem = new THREE.Points(particles, pMaterial);\n  particleSystem.position.y += 4;\n  particleSystem.sortParticles = true;\n\n  scene.add(particleSystem);\n\n  // -------------------------\n  // Надпись\n  // -------------------------\n\n  const textMaterial = createTextMaterial();\n  const geometry = new THREE.TextGeometry('Happy New Year 2020!', {\n    font: new THREE.Font(font),\n    size: 0.75,\n    height: 0.25,\n    curveSegments: 3,\n    bevelEnabled: true,\n    bevelThickness: 0.175,\n    bevelSize: 0.075,\n    bevelOffset: 0,\n    bevelSegments: 20,\n  });\n  geometry.vertices.forEach(v => {\n    v.x += (randomInstance.value() - 0.5) * 0.05;\n    v.y += (randomInstance.value() - 0.5) * 0.05;\n    v.z += (randomInstance.value() - 0.5) * 0.05;\n  });\n  const textMesh = new THREE.Mesh(geometry, textMaterial);\n  textMesh.rotateY(Math.PI);\n  textMesh.rotateX(-Math.PI * 0.25);\n  textMesh.position.x += 5;\n  textMesh.position.y += 0.5;\n  textMesh.position.z += 1.25;\n\n  textMesh.castShadow = true;\n  textMesh.receiveShadow = true;\n\n  scene.add(textMesh);\n\n  return {\n    resize({ pixelRatio, viewportWidth, viewportHeight }) {\n      renderer.setPixelRatio(pixelRatio);\n      renderer.setSize(viewportWidth, viewportHeight, false);\n      camera.aspect = viewportWidth / viewportHeight;\n      camera.updateProjectionMatrix();\n    },\n\n    render({ time, dimensions }) {\n      pMaterial.uniforms.iTime.value = time * 0.175;\n      pMaterial.uniforms.camPosition = new THREE.Uniform(camera.position);\n\n      camera.position.z = Math.min(camera.position.z, 0);\n      camera.position.y = Math.max(camera.position.y, 5);\n      camera.position.y = Math.min(camera.position.y, 15);\n\n      controls.update();\n      renderer.render(scene, camera);\n    },\n\n    unload() {\n      controls.dispose();\n      renderer.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}