{"version":3,"sources":["sketches/027_land_flow/shaders/vert.glsl","sketches/027_land_flow/shaders/frag.glsl","sketches/027_land_flow/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","Black","fogMode","FOGMODE_EXP2","fogDensity","fogColor","ShadersStore","customVertexShader","customFragmentShader","camera","Math","PI","Zero","panningSensibility","fov","pipeline","samples","chromaticAberrationEnabled","chromaticAberration","aberrationAmount","radialIntensity","imageProcessingEnabled","imageProcessing","contrast","exposure","vignetteEnabled","vignetteWeight","vignetteStretch","vignetteCameraFov","depthOfFieldEnabled","depthOfField","focalLength","fStop","focusDistance","lensSize","grainEnabled","grain","intensity","animated","ground","CreateGround","groundMaterial","vertex","fragment","attributes","uniforms","needAlphaBlending","material","wireframe","alphaMode","ALPHA_MAXIMIZED","setFloat","onBind","mesh","effect","getEffect","setFloat4","fogStart","fogEnd","setColor3","render","time","alpha","aRatio","getEngine","getAspectRatio","setVector2","resize","pixelRatio","unload","dispose","settings","animate","context"],"mappings":"iHAAA,OAAe,wrD,iCCAf,OAAe,suC,+FCSTA,EAAM,uCAAG,yCAAAC,EAAA,6DAASC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAGLC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAaJ,SAAeK,MAClCF,EAAMG,QAAUN,QAAcO,aAC9BJ,EAAMK,WAAa,KACnBL,EAAMM,SAAW,IAAIT,SAAe,EAAG,EAAG,GAE1CA,SAAeU,aAAaC,mBAAqBA,UACjDX,SAAeU,aAAaE,qBAAuBA,WAE7CC,EAAS,IAAIb,kBAAwB,UAAWc,KAAKC,GAAK,EAAGD,KAAKC,GAAK,EAAG,EAAGf,UAAgBgB,OAAQb,IAEpGc,mBAAqB,EAC5BJ,EAAOK,IAAM,GAIPC,EAAW,IAAInB,2BAAiC,oBAAoB,EAAMG,EAAO,CAACU,KAC/EO,QAAU,EAEnBD,EAASE,4BAA6B,EACtCF,EAASG,oBAAoBC,iBAAmB,IAChDJ,EAASG,oBAAoBE,gBAAkB,EAE/CL,EAASM,wBAAyB,EAClCN,EAASO,gBAAgBC,SAAW,IACpCR,EAASO,gBAAgBE,SAAW,IAEpCT,EAASO,gBAAgBG,iBAAkB,EAC3CV,EAASO,gBAAgBI,eAAiB,GAC1CX,EAASO,gBAAgBK,gBAAkB,GAC3CZ,EAASO,gBAAgBM,kBAAoB,GAE7Cb,EAASc,qBAAsB,EAC/Bd,EAASe,aAAaC,YAAc,KACpChB,EAASe,aAAaE,MAAQ,KAC9BjB,EAASe,aAAaG,cAAgB,KACtClB,EAASe,aAAaI,SAAW,GAEjCnB,EAASoB,cAAe,EACxBpB,EAASqB,MAAMC,UAAY,EAC3BtB,EAASqB,MAAME,UAAW,EAIpBC,EAAS,IAAI3C,OAAa4C,aAAa,SAAU,GAAI,GAAI,IAAKzC,GAE9D0C,EAAiB,IAAI7C,iBACzB,kBACAG,EACA,CACE2C,OAAQ,SACRC,SAAU,UAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,cAAe,YAAa,aACrGC,mBAAmB,IAIvBP,EAAOQ,SAAWN,EAClBA,EAAeO,WAAY,EAE3BP,EAAeQ,UAAYrD,SAAesD,gBAE1CT,EAAeU,SAAS,cAAe,IAAIvD,UAAgB,EAAG,IAE9D6C,EAAeW,OAAS,SAAAC,GACtB,IAAMC,EAASb,EAAec,YAC9BD,EAAOE,UAAU,YAAazD,EAAMG,QAASH,EAAM0D,SAAU1D,EAAM2D,OAAQ3D,EAAMK,YACjFkD,EAAOK,UAAU,YAAa5D,EAAMM,WA5EzB,kBA+EN,CACLuD,OADK,YACa,IAATC,EAAQ,EAARA,KACPpD,EAAOqD,OAAS,OAChBrB,EAAeU,SAAS,QAASU,GACjC,IAAME,EAAShE,EAAMiE,YAAYC,eAAexD,GAChDgC,EAAeyB,WAAW,cAAe,IAAItE,UAAgBmE,EAAQ,IAErEhE,EAAM6D,UAERO,OATK,YASiC,EAA7BC,WAA6B,EAAjB3E,MAAiB,EAAVC,OAC1BC,EAAOwE,UAETE,OAZK,WAaH1E,EAAO2E,aA5FE,4CAAH,sDAiGG,WAAEhF,SAAQiF,SAtGR,CACfC,SAAS,EACTC,QAAS","file":"static/js/42.33e4bcd2.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec3 normal;\\nattribute vec2 uv;\\n\\nuniform mat4 worldViewProjection;\\nuniform mat4 view;\\nuniform mat4 world;\\nuniform float iTime;\\n\\nvarying vec2 vUv;\\nvarying vec3 vpos;\\nvarying float fFogDistance;\\n\\n#define MOD3 vec3(.1031,.11369,.13787)\\n\\nvec3 hash33(vec3 p3)\\n{\\n  p3 = fract(p3 * MOD3);\\n  p3 += dot(p3, p3.yxz+19.19);\\n  return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\\n}\\n\\nfloat noise(vec3 p)\\n{\\n  const float K1 = 0.333333333;\\n  const float K2 = 0.166666667;\\n\\n  vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n  vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n\\n  vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n  vec3 i1 = e * (1.0 - e.zxy);\\n  vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n\\n  vec3 d1 = d0 - (i1 - 1.0 * K2);\\n  vec3 d2 = d0 - (i2 - 2.0 * K2);\\n  vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n\\n  vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n  vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n\\n  return dot(vec4(31.316), n);\\n}\\n\\nvoid main() {\\n  vec4 worldPosition = world * vec4(position, 1.0);\\n  fFogDistance = (view * worldPosition).z;\\n  vUv = uv;\\n  float t = iTime*50.25;\\n\\n  vpos = position;\\n\\n  vec3 nvpos = vpos + vec3(0, 0, t*.1);\\n\\n  vpos.y += noise(vec3(nvpos.x*.1, nvpos.z*.1, 0.))*1.5;\\n  vpos.y += noise(vec3(nvpos.x, nvpos.z, 0.))*.25;\\n  vpos.y += noise(vec3(nvpos.x*2., nvpos.z*2., 0.))*.1;\\n  vpos.y += noise(vec3(nvpos.x*5., nvpos.z*5., 0.))*.1;\\n  // vpos.y += noise(vec3(nvpos.xz*.5, t*5.5))*.25;\\n\\n  gl_Position = worldViewProjection * vec4( vpos, 1.0 );\\n}\\n\";","export default \"#define GLSLIFY 1\\nuniform float iTime;\\nuniform vec2 iResolution;\\n\\nvarying vec3 vpos;\\nvarying vec2 vUv;\\n\\n#define FOGMODE_NONE 0.\\n#define FOGMODE_EXP 1.\\n#define FOGMODE_EXP2 2.\\n#define FOGMODE_LINEAR 3.\\n#define E 2.71828\\n\\nuniform vec4 vFogInfos;\\nuniform vec3 vFogColor;\\nvarying float fFogDistance;\\n\\nfloat CalcFogFactor()\\n{\\n  float fogCoeff = 1.0;\\n  float fogStart = vFogInfos.y;\\n  float fogEnd = vFogInfos.z;\\n  float fogDensity = vFogInfos.w;\\n\\n  if (FOGMODE_LINEAR == vFogInfos.x)\\n  {\\n    fogCoeff = (fogEnd - fFogDistance) / (fogEnd - fogStart);\\n  }\\n  else if (FOGMODE_EXP == vFogInfos.x)\\n  {\\n    fogCoeff = 1.0 / pow(E, fFogDistance * fogDensity);\\n  }\\n  else if (FOGMODE_EXP2 == vFogInfos.x)\\n  {\\n    fogCoeff = 1.0 / pow(E, fFogDistance * fFogDistance * fogDensity * fogDensity);\\n  }\\n\\n  return clamp(fogCoeff, 0.0, 1.0);\\n}\\n\\n  #define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\\n{\\n  float fog = CalcFogFactor();\\n  vec3 color = hue(vpos.y*.2 + .725).rgb;\\n  color = fog * color + (1.0 - fog) * vFogColor;\\n  fragColor = vec4(color, 1.);\\n}\\n\\nvoid main()\\n{\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport customVertexShader from './shaders/vert.glsl';\nimport customFragmentShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = BABYLON.Color3.Black;\n  scene.fogMode = BABYLON.Scene.FOGMODE_EXP2;\n  scene.fogDensity = 0.125;\n  scene.fogColor = new BABYLON.Color3(0, 0, 0);\n\n  BABYLON.Effect.ShadersStore.customVertexShader = customVertexShader;\n  BABYLON.Effect.ShadersStore.customFragmentShader = customFragmentShader;\n\n  const camera = new BABYLON.ArcRotateCamera('Camera', -Math.PI / 2, Math.PI / 3, 5, BABYLON.Vector3.Zero(), scene);\n  // camera.attachControl(canvas, true);\n  camera.panningSensibility = 0;\n  camera.fov = 1;\n\n  // ========= VIDEO-FILTER =====================\n\n  const pipeline = new BABYLON.DefaultRenderingPipeline('default-pipeline', true, scene, [camera]);\n  pipeline.samples = 2;\n\n  pipeline.chromaticAberrationEnabled = true;\n  pipeline.chromaticAberration.aberrationAmount = 3.7;\n  pipeline.chromaticAberration.radialIntensity = 0;\n\n  pipeline.imageProcessingEnabled = true;\n  pipeline.imageProcessing.contrast = 1.1;\n  pipeline.imageProcessing.exposure = 1.1;\n\n  pipeline.imageProcessing.vignetteEnabled = true;\n  pipeline.imageProcessing.vignetteWeight = 0.1;\n  pipeline.imageProcessing.vignetteStretch = 0.1;\n  pipeline.imageProcessing.vignetteCameraFov = 0.3;\n\n  pipeline.depthOfFieldEnabled = false;\n  pipeline.depthOfField.focalLength = 2735;\n  pipeline.depthOfField.fStop = 16.9;\n  pipeline.depthOfField.focusDistance = 7169;\n  pipeline.depthOfField.lensSize = 38;\n\n  pipeline.grainEnabled = true;\n  pipeline.grain.intensity = 2;\n  pipeline.grain.animated = false;\n\n  // =================================================\n\n  const ground = new BABYLON.Mesh.CreateGround('ground', 40, 40, 600, scene);\n\n  const groundMaterial = new BABYLON.ShaderMaterial(\n    'ground-material',\n    scene,\n    {\n      vertex: 'custom',\n      fragment: 'custom',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'iTime', 'iResolution', 'vFogInfos', 'vFogColor'],\n      needAlphaBlending: true,\n    },\n  );\n\n  ground.material = groundMaterial;\n  groundMaterial.wireframe = true;\n\n  groundMaterial.alphaMode = BABYLON.Engine.ALPHA_MAXIMIZED;\n\n  groundMaterial.setFloat('iResolution', new BABYLON.Vector2(1, 1));\n\n  groundMaterial.onBind = mesh => {\n    const effect = groundMaterial.getEffect();\n    effect.setFloat4('vFogInfos', scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n    effect.setColor3('vFogColor', scene.fogColor);\n  };\n\n  return {\n    render({ time }) {\n      camera.alpha += 0.00125;\n      groundMaterial.setFloat('iTime', time);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      groundMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}