(this.webpackJsonpgenerative=this.webpackJsonpgenerative||[]).push([[38,62,63],{195:function(n,e,o){"use strict";o.r(e),e.default="#define GLSLIFY 1\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453)\n\nvarying vec3 vpos;\nvarying float vtime;\nuniform mat3 uvTransform;\n\nvoid main() {\n    vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\n\n    float g = length(uv);\n\n    g = .001 / smoothstep(.0, 20., g);\n\n    gl_FragColor = vec4(vec3(g), g*.0125);\n}\n"},196:function(n,e,o){"use strict";o.r(e),e.default="#define GLSLIFY 1\nvarying vec3 vpos;\nvarying float vtime;\n\nuniform float time;\n\n//\tSimplex 3D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 );\n    vec4 p = permute( permute( permute(\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n    dot(p2,x2), dot(p3,x3) ) );\n}\n\nvoid main() {\n    vpos = position;\n    vtime = time;\n    vec3 newPos = position;\n\n    newPos.x += sin(time + position.x * position.y)*.5;\n    newPos.y += cos(time + position.x * position.y * 1.1)*.5;\n    newPos.z += cos(time + position.x * position.y * 1.3)*.5;\n\n    gl_PointSize = 50. + snoise(position*.05 + vec3(0, 0, vtime*.1))*50.;\n    gl_PointSize *= .5;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\n}\n"},57:function(n,e,o){"use strict";o.r(e),function(n){var i=o(195),t=o(196),s=o(271);n.THREE=s,o(272);var r=o(298);e.default={sketch:function(n){var e=n.context,o=new s.WebGLRenderer({canvas:e.canvas});o.setClearColor("hsl(200, 40%, 10%)",1);var v=new s.PerspectiveCamera(40,10,.91,1e3);v.position.set(100,100,100),v.lookAt(new s.Vector3(110,110,110));var c=new s.OrbitControls(v,e.canvas);c.target=new s.Vector3(0,25,0);var a=new s.Scene,x=new s.GridHelper(100,20);a.add(x);var p=new s.HemisphereLight(16777215,0,1);a.add(p),r.positions.forEach((function(n){n[0]*=5,n[1]*=5,n[2]*=5}));var d=new s.Geometry;r.positions.forEach((function(n){d.vertices.push(new s.Vector3(n[0],n[1],n[2]))})),r.cells.forEach((function(n){d.vertices.push(new s.Vector3((r.positions[n[0]][0]+r.positions[n[1]][0]+r.positions[n[2]][0])/3,(r.positions[n[0]][1]+r.positions[n[1]][1]+r.positions[n[2]][1])/3,(r.positions[n[0]][2]+r.positions[n[1]][2]+r.positions[n[2]][2])/3))}));var m=s.ShaderLib.points,l=s.UniformsUtils.clone(m.uniforms);l.time={value:0};var y=new s.ShaderMaterial({uniforms:l,transparent:!0,depthWrite:!1,blending:s.AdditiveBlending,vertexShader:t.default,fragmentShader:i.default}),u=new s.Points(d,y);return a.add(u),{resize:function(n){var e=n.pixelRatio,i=n.viewportWidth,t=n.viewportHeight;o.setPixelRatio(e),o.setSize(i,t,!1),v.aspect=i/t,v.updateProjectionMatrix()},render:function(n){var e=n.time;y.uniforms.time.value=10*e,c.update(),o.render(a,v)},unload:function(){c.dispose(),o.dispose()}}},settings:{animate:!0,context:"webgl"}}}.call(this,o(28))}}]);
//# sourceMappingURL=38.d46dab3e.chunk.js.map