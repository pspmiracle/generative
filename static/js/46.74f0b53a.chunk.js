(this.webpackJsonpgenerative=this.webpackJsonpgenerative||[]).push([[46,118,119],{251:function(n,e,t){"use strict";t.r(e),e.default="#define GLSLIFY 1\nattribute vec3 position;\nattribute vec2 uv;\n\nvarying vec2 vUv;\nvarying vec3 pPos;\nvarying float rSize;\n\nuniform float iTime;\nuniform float aRatio;\nuniform float stackSize;\nuniform float sizeStep;\nuniform float pSize;\nuniform vec3 camPos;\n\nuniform mat4 worldViewProjection;\nuniform mat4 world;\n\n#define PI 3.1415926;\n#define PI2 6.28318530;\n#define rand1(p) fract(sin(p * 78.233) * 43758.5453)\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\nvoid main()\n{\n    vUv = uv;\n    pPos = position;\n\n    gl_PointSize = stackSize * sizeStep - position.y * sizeStep;\n\n    pPos.x += position.y*.01;\n    rSize = gl_PointSize;\n\n    float depth = position.y / stackSize;\n    float df =  (1. - depth);\n\n    float t = iTime;\n\n    vec3 p  = position * 100.;\n\n    float xf = snoise(vec3(p.x + depth, depth + t, p.z + depth)) *.15 * depth;\n    float zf = snoise(vec3(p.x + depth + 100., depth + t, p.z + depth)) *.15  * depth;\n\n    pPos.x += xf - depth*.25;\n    pPos.z += zf + depth*.125;\n\n    pPos.z /= aRatio;\n\n    gl_Position = worldViewProjection * vec4(pPos, 1.0);\n\n}\n"},252:function(n,e,t){"use strict";t.r(e),e.default="#define GLSLIFY 1\nvarying vec3 pPos;\nvarying float rSize;\n\nvarying vec2 vUv;\n\nuniform vec2 iResolution;\nuniform float iTime;\nuniform float stackSize;\n\n#define BLACK_COL vec3(16,22,26)/255.\n#define WHITE_COL vec3(235,241,245)/255.\n\n#define SF 2./min(iResolution.x, iResolution.y)\n#define SS(l, s) smoothstep(SF, -SF, l - s)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\n\n    float l = length(uv);\n\n    float sf = 2./rSize;\n\n    float circleLimit = smoothstep(.5, .5 - sf, l);\n\n    float ll = .1;\n    float g = smoothstep(sf, -sf, abs(l - (.5 - sf * 1.75)));\n\n    float depthFactor = pPos.y / stackSize;\n\n    vec3 col = mix(BLACK_COL, WHITE_COL, g * depthFactor);\n\n    fragColor = vec4(col, circleLimit);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, vUv * iResolution.xy);\n}\n"},84:function(n,e,t){"use strict";t.r(e);var o=t(21),i=t.n(o),r=t(37),a=t(27),s=t(268),c=t(251),v=t(252),l=function(){var n=Object(a.a)(i.a.mark((function n(e){var t,o,a,l,x,p,f,d,m,u,h,y,z,g,w,S;return i.a.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:for(t=e.canvas,e.width,e.height,o=new s.Engine(t,!0,{preserveDrawingBuffer:!0,stencil:!0}),(a=new s.Scene(o)).clearColor=new s.Color3(16/255,22/255,26/255),s.Effect.ShadersStore.particlesVertexShader=c.default,s.Effect.ShadersStore.particlesFragmentShader=v.default,(l=new s.ArcRotateCamera("camera1",0,0,1e4,s.Vector3(0,-1,1),a)).setTarget(s.Vector3.Zero()),l.mode=s.Camera.ORTHOGRAPHIC_CAMERA,l.orthoTop=1,l.orthoBottom=-1,l.orthoLeft=-1,l.orthoRight=1,x=new s.PointsCloudSystem("pcs",0,a),p=.75,f=150,d=a.getEngine().getAspectRatio(l),m=200*d,u=[],h=0;h<m;h+=1)y=2*(Math.random()-.5),z=2*(Math.random()-.5)*d,u.push([y,z]);for(g=function(n){u.forEach((function(e){var t=Object(r.a)(e,2),o=t[0],i=t[1];x.addPoints(1,(function(e){e.position=new s.Vector3(o,n,i)}))}))},w=0;w<f;w+=1)g(w);return n.next=24,x.buildMeshAsync();case 24:return(S=new s.ShaderMaterial("shader",a,{vertex:"particles",fragment:"particles"},{attributes:["position","normal","uv"],uniforms:["world","worldView","worldViewProjection","view","iTime","iResolution","pSize","stackSize","sizeStep","aRatio"],needAlphaBlending:!0})).pointsCloud=!0,S.setFloat("iResolution",new s.Vector2(1,1)),S.setFloat("pSize",1),S.setFloat("stackSize",f),S.setFloat("sizeStep",p),S.setFloat("aRatio",1),x.mesh.material=S,n.abrupt("return",{render:function(n){var e=n.time,t=n.width,o=n.height;S.setFloat("iTime",e),S.setFloat("aRatio",t/o);var i=a.getEngine().getAspectRatio(l);S.setVector2("iResolution",new s.Vector2(i,1)),a.render()},resize:function(n){n.pixelRatio,n.width,n.height;o.resize()},unload:function(){o.dispose()}});case 33:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}();e.default={sketch:l,settings:{animate:!0,context:"webgl"}}}}]);
//# sourceMappingURL=46.74f0b53a.chunk.js.map