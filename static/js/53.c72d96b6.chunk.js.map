{"version":3,"sources":["sketches/023_square_tunnel/index.js"],"names":["sketch","canvas","engine","width","height","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","intensity","camera","Math","PI","wheelDeltaPercentage","disableLighting","path","colors","Array","length","fill","map","squares","i","square","CreateLines","points","material","emissiveColor","alpha","idx","originalPosZ","position","z","push","render","time","rotation","cos","HSVtoRGBToRef","scaleToRef","sqrt","abs","squaresCount","fov","sin","resize","pixelRatio","unload","dispose","settings","dimensions","animate","context"],"mappings":"0GAAA,oBAmGe,WAAEA,OA3FF,SAAC,GAA+B,IAA7BC,EAA4B,EAA5BA,OACVC,GADsC,EAApBC,MAAoB,EAAbC,OAChB,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAGLC,EAAQ,IAAIH,QAAcH,GAChCM,EAAMC,WAAa,IAAIJ,SAAe,EAAK,GAAK,IAGrC,IAAIA,YAAkB,OAAQG,GACtCE,UAAY,EAEf,IAAMC,EAAS,IAAIN,kBACjB,UACAO,KAAKC,GAAK,EACVD,KAAKC,GAAK,EACV,GACA,IAAIR,UAAgB,EAAG,EAAG,GAC1BG,GAEFG,EAAOG,qBAAuB,IAEhB,IAAIT,mBAAyB,QAAS,IAAIA,UAAgB,EAAG,EAAG,GAAIG,GAC5EE,UAAY,KAEN,IAAIL,mBAAyB,MAAOG,GAC5CO,iBAAkB,EAkBtB,IAfA,IAAMC,EAAO,CACX,IAAIX,WAAiB,EAAK,EAAK,GAC/B,IAAIA,UAAgB,EAAK,EAAG,GAC5B,IAAIA,UAAgB,EAAK,EAAG,GAC5B,IAAIA,UAAgB,GAAM,EAAG,GAC7B,IAAIA,WAAiB,EAAK,EAAK,IAG3BY,EAAS,IAAIC,MAAMF,EAAKG,QAAQC,KAAK,GAAGC,KAAI,kBAAM,IAAIhB,SAAe,EAAG,EAAG,EAAG,MAM9EiB,EAAU,GACPC,EAAI,EAAGA,EALK,IAKaA,GAAK,EAAG,CACxC,IAAMC,EAASnB,cAAoBoB,YAAY,OAAQ,CAAEC,OAAQV,EAAMC,UAAUT,GACjFgB,EAAOG,SAASC,cAAgB,IAAIvB,SAAe,EAAG,GAAK,GAC3DmB,EAAOG,SAASZ,iBAAkB,EAClCS,EAAOG,SAASE,MAAQ,EAExBL,EAAOM,IAAMP,EACbC,EAAOO,aAXI,GAWYP,EAAOM,IAE9BN,EAAOQ,SAASC,EAAIT,EAAOO,aAE3BT,EAAQY,KAAKV,GAGf,MAAO,CACLW,OADK,YAEH,IADgB,IAATC,EAAQ,EAARA,KACEb,EAAI,EAAGA,EArBC,IAqBiBA,GAAK,EAAG,CACxC,IAAMC,EAASF,EAAQC,GACvBC,EAAOQ,SAASC,EAAIT,EAAOO,aAAsB,GAAPK,EAC1CZ,EAAOa,SAASJ,EAAKrB,KAAK0B,IAAIF,EAAoB,GAAbZ,EAAOM,KAAalB,KAAKC,GAAM,EAEpER,SAAekC,cAA4B,GAAbf,EAAOM,IAAY,IAAK,EAAG,EAAGN,EAAOG,SAASC,eAC5EJ,EAAOG,SAASC,cAAcY,WAC5B,EAAI5B,KAAK6B,KAAK7B,KAAK8B,IAAIlB,EAAOQ,SAASC,EA1BlCU,MA2BLnB,EAAOG,SAASC,eAGdJ,EAAOQ,SAASC,EAAI,IACtBT,EAAOM,KAjCM,IAkCbN,EAAOO,aAjCF,GAiCkBP,EAAOM,KAIlCnB,EAAOiC,IAA2C,KAAf,IAArBhC,KAAKiC,IAAW,EAAPT,GAAmB,KAAe,KAEzD5B,EAAM2B,UAERW,OAvBK,YAuBiC,EAA7BC,WAA6B,EAAjB5C,MAAiB,EAAVC,OAC1BF,EAAO4C,UAETE,OA1BK,WA2BH9C,EAAO+C,aAKYC,SAjGR,CACfC,WAAY,CAAC,KAAM,MACnBC,SAAS,EACTC,QAAS","file":"static/js/53.c72d96b6.chunk.js","sourcesContent":["import * as BABYLON from 'babylonjs';\n\nconst settings = {\n  dimensions: [1280, 1280],\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = new BABYLON.Color3(0.0, 0.1, 0.2);\n\n  // Make scene glowing\n  const gl = new BABYLON.GlowLayer('glow', scene);\n  gl.intensity = 2.0;\n\n  const camera = new BABYLON.ArcRotateCamera(\n    'camera1',\n    Math.PI / 2,\n    Math.PI / 2,\n    0.1,\n    new BABYLON.Vector3(0, 0, 0),\n    scene,\n  );\n  camera.wheelDeltaPercentage = 0.01;\n\n  const light = new BABYLON.HemisphericLight('light', new BABYLON.Vector3(0, 1, 0), scene);\n  light.intensity = 10.7;\n\n  const mat = new BABYLON.StandardMaterial('mat', scene);\n  mat.disableLighting = true;\n\n  // Square path\n  const path = [\n    new BABYLON.Vector3(-1.0, 0.0, 0.0),\n    new BABYLON.Vector3(0.0, 1, 0.0),\n    new BABYLON.Vector3(1.0, 0, 0.0),\n    new BABYLON.Vector3(0.0, -1, 0.0),\n    new BABYLON.Vector3(-1.0, 0.0, 0.0),\n  ];\n\n  const colors = new Array(path.length).fill(0).map(() => new BABYLON.Color4(1, 1, 1, 1));\n\n  const squaresCount = 100;\n  const step = 1.0;\n  const maxZ = squaresCount * step;\n\n  const squares = [];\n  for (let i = 0; i < squaresCount; i += 1) {\n    const square = BABYLON.MeshBuilder.CreateLines('tube', { points: path, colors }, scene);\n    square.material.emissiveColor = new BABYLON.Color3(1, 0.5, 0);\n    square.material.disableLighting = true;\n    square.material.alpha = 1;\n\n    square.idx = i;\n    square.originalPosZ = -square.idx * step;\n\n    square.position.z = square.originalPosZ;\n\n    squares.push(square);\n  }\n\n  return {\n    render({ time }) {\n      for (let i = 0; i < squaresCount; i += 1) {\n        const square = squares[i];\n        square.position.z = square.originalPosZ + time * 10;\n        square.rotation.z = (Math.cos(time + square.idx * 0.1) * Math.PI) / 2;\n\n        BABYLON.Color3.HSVtoRGBToRef((square.idx * 10) % 360, 1, 1, square.material.emissiveColor);\n        square.material.emissiveColor.scaleToRef(\n          1 - Math.sqrt(Math.abs(square.position.z / maxZ)),\n          square.material.emissiveColor,\n        );\n\n        if (square.position.z > 0) {\n          square.idx += squaresCount;\n          square.originalPosZ = -square.idx * step;\n        }\n      }\n\n      camera.fov = (Math.sin(time * 3) * 0.25 + 0.75) * 0.25 + 0.525;\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}