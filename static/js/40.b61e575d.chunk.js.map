{"version":3,"sources":["sketches/020_unstable_sphere/shaders/vert.glsl","sketches/020_unstable_sphere/shaders/frag.glsl","sketches/020_unstable_sphere/index.js"],"names":["THREE","require","global","sketch","context","renderer","WebGLRenderer","canvas","setClearColor","camera","PerspectiveCamera","position","set","lookAt","Vector3","controls","OrbitControls","scene","Scene","particles","OctahedronGeometry","vertices","map","v","x","Math","random","y","z","shaderPoint","ShaderLib","points","uniforms","iTime","value","pSize","pMaterial","ShaderMaterial","transparent","depthWrite","blending","AdditiveBlending","fragmentShader","vertexShader","particleSystem","Points","sortParticles","add","resize","pixelRatio","viewportWidth","viewportHeight","setPixelRatio","setSize","aspect","updateProjectionMatrix","render","time","dimensions","cos","sin","update","unload","dispose","settings","animate"],"mappings":"iHAAA,OAAe,0oM,iCCAf,OAAe,i+C,iFCGTA,EAAQC,EAAQ,KAEtBC,EAAOF,MAAQA,EAEfC,EAAQ,KA+EO,WAAEE,OAxEF,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAEVC,EAAW,IAAIL,EAAMM,cAAc,CACvCC,OAAQH,EAAQG,SAGlBF,EAASG,cAAc,qBAAsB,GAE7C,IAAMC,EAAS,IAAIT,EAAMU,kBAAkB,GAAI,EAAG,IAAM,KACxDD,EAAOE,SAASC,IAAI,GAAI,KAAM,GAE9BH,EAAOI,OAAO,IAAIb,EAAMc,SACxB,IAAMC,EAAW,IAAIf,EAAMgB,cAAcP,EAAQL,EAAQG,QAEnDU,EAAQ,IAAIjB,EAAMkB,MAElBC,EAAY,IAAInB,EAAMoB,mBAAmB,EAAG,GAClDD,EAAUE,SAAWF,EAAUE,SAASC,KAAI,SAAAC,GAI1C,OAHAA,EAAEC,GAA6B,KAAvBC,KAAKC,SAAW,IACxBH,EAAEI,GAA6B,KAAvBF,KAAKC,SAAW,IACxBH,EAAEK,GAA6B,KAAvBH,KAAKC,SAAW,IACjBH,KAGT,IAAMM,EAAc7B,EAAM8B,UAAUC,OAC9BC,EAAQ,eACTH,EAAYG,SADH,CAEZC,MAAO,CAAEC,MAAO,GAChBC,MAAO,CAAED,MAAO,MAGZE,EAAY,IAAIpC,EAAMqC,eAAe,CACzCL,WACAM,aAAa,EACbC,YAAY,EAEZC,SAAUxC,EAAMyC,iBAEhBC,yBACAC,yBAGIC,EAAiB,IAAI5C,EAAM6C,OAAO1B,EAAWiB,GAKnD,OAJAQ,EAAeE,eAAgB,EAE/B7B,EAAM8B,IAAIH,GAEH,CACLI,OADK,YACkD,IAA9CC,EAA6C,EAA7CA,WAAYC,EAAiC,EAAjCA,cAAeC,EAAkB,EAAlBA,eAClC9C,EAAS+C,cAAcH,GACvB5C,EAASgD,QAAQH,EAAeC,GAAgB,GAChD1C,EAAO6C,OAASJ,EAAgBC,EAChC1C,EAAO8C,0BAGTC,OARK,YAQyB,IAArBC,EAAoB,EAApBA,KAAoB,EAAdC,WACbtB,EAAUJ,SAASC,MAAMC,MAAe,KAAPuB,EAEjChD,EAAOE,SAASa,EAAI,EAAIC,KAAKkC,IAAW,KAAPF,GACjChD,EAAOE,SAASiB,EAAI,EAAIH,KAAKmC,IAAW,KAAPH,GAEjC1C,EAAS8C,SACTxD,EAASmD,OAAOvC,EAAOR,IAGzBqD,OAlBK,WAmBH/C,EAASgD,UACT1D,EAAS0D,aAKUC,SA7ER,CACfC,SAAS,EACT7D,QAAS,W","file":"static/js/40.b61e575d.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvarying vec2 vUv;\\nvarying vec3 vpos;\\nvarying float hp;\\nvarying float hp2;\\nvarying float hp3;\\n\\nuniform float iTime;\\nuniform float pSize;\\n\\nfloat hash(vec3 p)// replace this by something better\\n{\\n  p  = fract(p*0.3183099+.1);\\n  p *= 17.0;\\n  return fract(p.x*p.y*p.z*(p.x+p.y+p.z));\\n}\\n\\nvoid main() {\\n  vUv = uv;\\n\\n  hp = hash(position); // Рандомный фактор для точки по позиции\\n  hp2 = hash(position*3.3); // Дополнительный рандомный фактор\\n  hp3 = hash(position*6.6); // Еще один рандомный фактор\\n\\n  float t = iTime*.5 + hp; // Замедляем время и прибавляем рандомный фактор - у этой точки будет \\\"своё\\\" время\\n\\n  vpos = position;\\n\\n  // индивидульный рандомнеый vec3 для точки для определения движения точки\\n  vec3 npp = vec3(hash(position), hash(position*10.), hash(position*20.))*2.;\\n\\n  // Фактор смещения через симплексный шум\\n  float nF = snoise((npp + vec3(iTime*.525)) * 1.) * (.25 + fract(t))*.5;\\n\\n  // фактор движения - определяем только часть точек которые будут летать\\n  float mF = step(hp2, .3);\\n\\n  // Дивгаем точки (те которые попали в mF, остальные на месте)\\n  vpos.xyz = vpos.xyz + (vpos.xyz * fract(t)*2. ) * mF;\\n\\n  // Добавляем к отлетающей точке фактор плавающего смещения\\n  vpos.xyz += nF * mF;\\n\\n  gl_PointSize = pSize;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( vpos, 1.0 );\\n}\\n\";","export default \"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec3 vpos;\\nvarying float hp;\\nvarying float hp2;\\nvarying float hp3;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\nuniform float pSize;\\n\\nuniform mat3 uvTransform;\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\\n  vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  float t = iTime*.5 + hp; // Делаем время для точки такое же как в vertexShader\\n\\n  float g = length(uv) * pSize;\\n  float gx = .05 / smoothstep(.0, pSize, g);\\n\\n  float tr = step(.3, hp2);\\n  if(tr == 0.){\\n    // Для отрывающихся точке будем делать затухание\\n    tr = 1. - fract(t);\\n  }\\n\\n  // Прозрачность считаем от hp3 чтоб все точки были с разной яркостью\\n  fragColor = vec4(vec3(gx) / g, hp3 * tr);\\n}\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import vertexShader from './shaders/vert.glsl';\nimport fragmentShader from './shaders/frag.glsl';\n\nconst THREE = require('three');\n\nglobal.THREE = THREE;\n\nrequire('three/examples/js/controls/OrbitControls');\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = ({ context }) => {\n  // Create a renderer\n  const renderer = new THREE.WebGLRenderer({\n    canvas: context.canvas,\n  });\n\n  renderer.setClearColor('hsl(100, 10%, 10%)', 1);\n\n  const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);\n  camera.position.set(2, -1.5, -1);\n\n  camera.lookAt(new THREE.Vector3());\n  const controls = new THREE.OrbitControls(camera, context.canvas);\n\n  const scene = new THREE.Scene();\n\n  const particles = new THREE.OctahedronGeometry(1, 5);\n  particles.vertices = particles.vertices.map(v => {\n    v.x += (Math.random() - 0.5) * 0.05;\n    v.y += (Math.random() - 0.5) * 0.05;\n    v.z += (Math.random() - 0.5) * 0.05;\n    return v;\n  });\n\n  const shaderPoint = THREE.ShaderLib.points;\n  const uniforms = {\n    ...shaderPoint.uniforms,\n    iTime: { value: 0 },\n    pSize: { value: 10 },\n  };\n\n  const pMaterial = new THREE.ShaderMaterial({\n    uniforms,\n    transparent: true,\n    depthWrite: false,\n\n    blending: THREE.AdditiveBlending,\n\n    fragmentShader,\n    vertexShader,\n  });\n\n  const particleSystem = new THREE.Points(particles, pMaterial);\n  particleSystem.sortParticles = true;\n\n  scene.add(particleSystem);\n\n  return {\n    resize({ pixelRatio, viewportWidth, viewportHeight }) {\n      renderer.setPixelRatio(pixelRatio);\n      renderer.setSize(viewportWidth, viewportHeight, false);\n      camera.aspect = viewportWidth / viewportHeight;\n      camera.updateProjectionMatrix();\n    },\n\n    render({ time, dimensions }) {\n      pMaterial.uniforms.iTime.value = time * 0.175;\n\n      camera.position.x = 5 * Math.cos(time * 0.125);\n      camera.position.z = 5 * Math.sin(time * 0.125);\n\n      controls.update();\n      renderer.render(scene, camera);\n    },\n\n    unload() {\n      controls.dispose();\n      renderer.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}