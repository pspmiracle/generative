{"version":3,"sources":["sketches/019_particles_sphere/shaders/frag.glsl","sketches/019_particles_sphere/shaders/vert.glsl","sketches/019_particles_sphere/index.js"],"names":["THREE","require","global","sketch","context","renderer","WebGLRenderer","canvas","setClearColor","camera","PerspectiveCamera","position","set","lookAt","Vector3","controls","OrbitControls","scene","Scene","particles","OctahedronGeometry","shaderPoint","ShaderLib","points","uniforms","iTime","value","pSize","pMaterial","ShaderMaterial","transparent","depthWrite","blending","AdditiveBlending","fragmentShader","vertexShader","particleSystem","Points","sortParticles","add","resize","pixelRatio","viewportWidth","viewportHeight","setPixelRatio","setSize","aspect","updateProjectionMatrix","render","time","dimensions","update","unload","dispose","settings","animate"],"mappings":"iHAAA,OAAe,+0B,iCCAf,OAAe,q7G,iFCGTA,EAAQC,EAAQ,KAEtBC,EAAOF,MAAQA,EAEfC,EAAQ,KA6EO,WAAEE,OAtEF,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAEVC,EAAW,IAAIL,EAAMM,cAAc,CACvCC,OAAQH,EAAQG,SAIlBF,EAASG,cAAc,qBAAsB,GAG7C,IAAMC,EAAS,IAAIT,EAAMU,kBAAkB,GAAI,EAAG,IAAM,KACxDD,EAAOE,SAASC,IAAI,GAAI,KAAM,GAE9BH,EAAOI,OAAO,IAAIb,EAAMc,SAGxB,IAAMC,EAAW,IAAIf,EAAMgB,cAAcP,EAAQL,EAAQG,QAGnDU,EAAQ,IAAIjB,EAAMkB,MAGlBC,EAAY,IAAInB,EAAMoB,mBAAmB,EAAG,GAE5CC,EAAcrB,EAAMsB,UAAUC,OAC9BC,EAAQ,eACTH,EAAYG,SADH,CAEZC,MAAO,CAAEC,MAAO,GAChBC,MAAO,CAAED,MAAO,KAGZE,EAAY,IAAI5B,EAAM6B,eAAe,CACzCL,WACAM,aAAa,EACbC,YAAY,EAEZC,SAAUhC,EAAMiC,iBAChBC,yBACAC,yBAGIC,EAAiB,IAAIpC,EAAMqC,OAAOlB,EAAWS,GAMnD,OALAQ,EAAeE,eAAgB,EAE/BrB,EAAMsB,IAAIH,GAGH,CAELI,OAFK,YAEkD,IAA9CC,EAA6C,EAA7CA,WAAYC,EAAiC,EAAjCA,cAAeC,EAAkB,EAAlBA,eAClCtC,EAASuC,cAAcH,GACvBpC,EAASwC,QAAQH,EAAeC,GAAgB,GAChDlC,EAAOqC,OAASJ,EAAgBC,EAChClC,EAAOsC,0BAGTC,OATK,YASyB,IAArBC,EAAoB,EAApBA,KAAoB,EAAdC,WACbtB,EAAUJ,SAASC,MAAMC,MAAe,IAAPuB,EAEjClC,EAASoC,SACT9C,EAAS2C,OAAO/B,EAAOR,IAGzB2C,OAhBK,WAiBHrC,EAASsC,UACThD,EAASgD,aAKUC,SA3ER,CACfC,SAAS,EACTnD,QAAS,W","file":"static/js/39.b2ffd186.chunk.js","sourcesContent":["export default \"precision highp float;\\n#define GLSLIFY 1\\n\\nvarying vec3 vpos;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\n\\nvarying float fogDepth;\\nvarying float size;\\nuniform float fogDensity;\\n\\nuniform mat3 uvTransform;\\n\\n#define PI 3.1415926\\n#define TAU 6.2831852\\n#define BLACK_COL vec3(24,32,38)/255.\\n\\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453)\\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\\n  vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  float g = length(uv) * size;\\n\\n  g = (size*.1) / smoothstep(.0, size*.5, g);\\n\\n  fragColor = vec4(hue(length(vpos) * size * .75).rgb * g, g*.75);\\n}\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","export default \"#define GLSLIFY 1\\n//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : ijm\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n  {\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\\nvarying vec2 vUv;\\nvarying vec3 vpos;\\nvarying float size;\\n\\nuniform float iTime;\\nuniform float pSize;\\n\\nvoid main() {\\n  vUv = uv;\\n  float t = iTime*.025;\\n\\n  vpos = position;\\n\\n  vpos.xyz *= 1. + snoise(position*1.5 + vec3(iTime*.5))*.15;\\n  vpos.xyz *= 1. + snoise(position*5.5 + vec3(iTime*.5))*.075;\\n  vpos.xyz *= 1. + snoise(position*10.5 + vec3(iTime*.5))*.025;\\n\\n  size = pSize;\\n  gl_PointSize = pSize + (length(vpos)-.75)*10.;\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( vpos, 1.0 );\\n}\\n\";","import fragmentShader from './shaders/frag.glsl';\nimport vertexShader from './shaders/vert.glsl';\n\nconst THREE = require('three');\n\nglobal.THREE = THREE;\n\nrequire('three/examples/js/controls/OrbitControls');\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = ({ context }) => {\n  // Create a renderer\n  const renderer = new THREE.WebGLRenderer({\n    canvas: context.canvas,\n  });\n\n  // WebGL background color\n  renderer.setClearColor('hsl(100, 10%, 10%)', 1);\n\n  // Setup a camera\n  const camera = new THREE.PerspectiveCamera(50, 1, 0.01, 100);\n  camera.position.set(2, -1.5, -1);\n\n  camera.lookAt(new THREE.Vector3());\n\n  // Setup camera controller\n  const controls = new THREE.OrbitControls(camera, context.canvas);\n\n  // Setup your scene\n  const scene = new THREE.Scene();\n\n  // create the particle variables\n  const particles = new THREE.OctahedronGeometry(1, 7);\n\n  const shaderPoint = THREE.ShaderLib.points;\n  const uniforms = {\n    ...shaderPoint.uniforms,\n    iTime: { value: 0 },\n    pSize: { value: 4 },\n  };\n\n  const pMaterial = new THREE.ShaderMaterial({\n    uniforms,\n    transparent: true,\n    depthWrite: false,\n\n    blending: THREE.AdditiveBlending,\n    fragmentShader,\n    vertexShader,\n  });\n\n  const particleSystem = new THREE.Points(particles, pMaterial);\n  particleSystem.sortParticles = true;\n\n  scene.add(particleSystem);\n\n  // draw each frame\n  return {\n    // Handle resize events here\n    resize({ pixelRatio, viewportWidth, viewportHeight }) {\n      renderer.setPixelRatio(pixelRatio);\n      renderer.setSize(viewportWidth, viewportHeight, false);\n      camera.aspect = viewportWidth / viewportHeight;\n      camera.updateProjectionMatrix();\n    },\n    // Update & render your scene here\n    render({ time, dimensions }) {\n      pMaterial.uniforms.iTime.value = time * 0.75;\n\n      controls.update();\n      renderer.render(scene, camera);\n    },\n    // Dispose of events & renderer for cleaner hot-reloading\n    unload() {\n      controls.dispose();\n      renderer.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}