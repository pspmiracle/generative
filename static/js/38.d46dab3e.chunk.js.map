{"version":3,"sources":["sketches/018_firefly_rabbit/shaders/frag.glsl","sketches/018_firefly_rabbit/shaders/vert.glsl","sketches/018_firefly_rabbit/index.js"],"names":["THREE","require","global","bunny","sketch","context","renderer","WebGLRenderer","canvas","setClearColor","camera","PerspectiveCamera","position","set","lookAt","Vector3","controls","OrbitControls","target","scene","Scene","gridHelper","GridHelper","add","light","HemisphereLight","positions","forEach","i","starsGeometry","Geometry","vertices","push","cells","shaderPoint","ShaderLib","points","uniforms","UniformsUtils","clone","time","value","pMaterial","ShaderMaterial","transparent","depthWrite","blending","AdditiveBlending","vertexShader","fragmentShader","particles","Points","resize","pixelRatio","viewportWidth","viewportHeight","setPixelRatio","setSize","aspect","updateProjectionMatrix","render","update","unload","dispose","settings","animate"],"mappings":"iHAAA,OAAe,8c,iCCAf,OAAe,wqF,gCCAf,yCAGMA,EAAQC,EAAQ,KAEtBC,EAAOF,MAAQA,EAEfC,EAAQ,KAER,IAAME,EAAQF,EAAQ,KAgGP,WAAEG,OAzFF,SAAC,GAAiB,IAAfC,EAAc,EAAdA,QAEVC,EAAW,IAAIN,EAAMO,cAAc,CACvCC,OAAQH,EAAQG,SAIlBF,EAASG,cAAc,qBAAsB,GAG7C,IAAMC,EAAS,IAAIV,EAAMW,kBAAkB,GAAI,GAAI,IAAM,KACzDD,EAAOE,SAASC,IAAI,IAAK,IAAK,KAC9BH,EAAOI,OAAO,IAAId,EAAMe,QAAQ,IAAK,IAAK,MAG1C,IAAMC,EAAW,IAAIhB,EAAMiB,cAAcP,EAAQL,EAAQG,QACzDQ,EAASE,OAAS,IAAIlB,EAAMe,QAAQ,EAAG,GAAI,GAE3C,IAAMI,EAAQ,IAAInB,EAAMoB,MAElBC,EAAa,IAAIrB,EAAMsB,WAAW,IAAK,IAC7CH,EAAMI,IAAIF,GAEV,IAAMG,EAAQ,IAAIxB,EAAMyB,gBAAgB,SAAU,EAAU,GAC5DN,EAAMI,IAAIC,GAEVrB,EAAMuB,UAAUC,SAAQ,SAAAC,GACtBA,EAAE,IAAM,EACRA,EAAE,IAAM,EACRA,EAAE,IAAM,KAGV,IAAMC,EAAgB,IAAI7B,EAAM8B,SAEhC3B,EAAMuB,UAAUC,SAAQ,SAAAC,GACtBC,EAAcE,SAASC,KAAK,IAAIhC,EAAMe,QAAQa,EAAE,GAAIA,EAAE,GAAIA,EAAE,QAE9DzB,EAAM8B,MAAMN,SAAQ,SAAAC,GAClBC,EAAcE,SAASC,KACrB,IAAIhC,EAAMe,SACPZ,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,IAAM,GAClFzB,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,IAAM,GAClFzB,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,GAAKzB,EAAMuB,UAAUE,EAAE,IAAI,IAAM,OAKzF,IAAMM,EAAclC,EAAMmC,UAAUC,OAC9BC,EAAWrC,EAAMsC,cAAcC,MAAML,EAAYG,UACvDA,EAASG,KAAO,CACdC,MAAO,GAGT,IAAMC,EAAY,IAAI1C,EAAM2C,eAAe,CACzCN,WACAO,aAAa,EACbC,YAAY,EAEZC,SAAU9C,EAAM+C,iBAEhBC,uBACAC,2BAGIC,EAAY,IAAIlD,EAAMmD,OAAOtB,EAAea,GAGlD,OAFAvB,EAAMI,IAAI2B,GAEH,CACLE,OADK,YACkD,IAA9CC,EAA6C,EAA7CA,WAAYC,EAAiC,EAAjCA,cAAeC,EAAkB,EAAlBA,eAClCjD,EAASkD,cAAcH,GACvB/C,EAASmD,QAAQH,EAAeC,GAAgB,GAChD7C,EAAOgD,OAASJ,EAAgBC,EAChC7C,EAAOiD,0BAGTC,OARK,YAQa,IAATpB,EAAQ,EAARA,KACPE,EAAUL,SAASG,KAAKC,MAAe,GAAPD,EAEhCxB,EAAS6C,SACTvD,EAASsD,OAAOzC,EAAOT,IAGzBoD,OAfK,WAgBH9C,EAAS+C,UACTzD,EAASyD,aAKUC,SA9FR,CACfC,SAAS,EACT5D,QAAS,W","file":"static/js/38.d46dab3e.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\n#define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n#define rand1(p) fract(sin(p* 78.233)* 43758.5453)\\n\\nvarying vec3 vpos;\\nvarying float vtime;\\nuniform mat3 uvTransform;\\n\\nvoid main() {\\n    vec2 uv = (uvTransform * vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n    float g = length(uv);\\n\\n    g = .001 / smoothstep(.0, 20., g);\\n\\n    gl_FragColor = vec4(vec3(g), g*.0125);\\n}\\n\";","export default \"#define GLSLIFY 1\\nvarying vec3 vpos;\\nvarying float vtime;\\n\\nuniform float time;\\n\\n//\\tSimplex 3D Noise\\n//\\tby Ian McEwan, Ashima Arts\\n//\\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\\n\\nfloat snoise(vec3 v){\\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n    // First corner\\n    vec3 i  = floor(v + dot(v, C.yyy) );\\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n    // Other corners\\n    vec3 g = step(x0.yzx, x0.xyz);\\n    vec3 l = 1.0 - g;\\n    vec3 i1 = min( g.xyz, l.zxy );\\n    vec3 i2 = max( g.xyz, l.zxy );\\n\\n    //  x0 = x0 - 0. + 0.0 * C\\n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\\n\\n    // Permutations\\n    i = mod(i, 289.0 );\\n    vec4 p = permute( permute( permute(\\n    i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n    // Gradients\\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\\n    float n_ = 1.0/7.0; // N=7\\n    vec3  ns = n_ * D.wyz - D.xzx;\\n\\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\\n\\n    vec4 x_ = floor(j * ns.z);\\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n    vec4 x = x_ *ns.x + ns.yyyy;\\n    vec4 y = y_ *ns.x + ns.yyyy;\\n    vec4 h = 1.0 - abs(x) - abs(y);\\n\\n    vec4 b0 = vec4( x.xy, y.xy );\\n    vec4 b1 = vec4( x.zw, y.zw );\\n\\n    vec4 s0 = floor(b0)*2.0 + 1.0;\\n    vec4 s1 = floor(b1)*2.0 + 1.0;\\n    vec4 sh = -step(h, vec4(0.0));\\n\\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n    vec3 p0 = vec3(a0.xy,h.x);\\n    vec3 p1 = vec3(a0.zw,h.y);\\n    vec3 p2 = vec3(a1.xy,h.z);\\n    vec3 p3 = vec3(a1.zw,h.w);\\n\\n    //Normalise gradients\\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n    p0 *= norm.x;\\n    p1 *= norm.y;\\n    p2 *= norm.z;\\n    p3 *= norm.w;\\n\\n    // Mix final noise value\\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n    m = m * m;\\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n    dot(p2,x2), dot(p3,x3) ) );\\n}\\n\\nvoid main() {\\n    vpos = position;\\n    vtime = time;\\n    vec3 newPos = position;\\n\\n    newPos.x += sin(time + position.x * position.y)*.5;\\n    newPos.y += cos(time + position.x * position.y * 1.1)*.5;\\n    newPos.z += cos(time + position.x * position.y * 1.3)*.5;\\n\\n    gl_PointSize = 50. + snoise(position*.05 + vec3(0, 0, vtime*.1))*50.;\\n    gl_PointSize *= .5;\\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(newPos, 1.0);\\n}\\n\";","import fragmentShader from './shaders/frag.glsl';\nimport vertexShader from './shaders/vert.glsl';\n\nconst THREE = require('three');\n\nglobal.THREE = THREE;\n\nrequire('three/examples/js/controls/OrbitControls');\n\nconst bunny = require('bunny');\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = ({ context }) => {\n  // Create a renderer\n  const renderer = new THREE.WebGLRenderer({\n    canvas: context.canvas,\n  });\n\n  // WebGL background color\n  renderer.setClearColor('hsl(200, 40%, 10%)', 1);\n\n  // Setup a camera\n  const camera = new THREE.PerspectiveCamera(40, 10, 0.91, 1000);\n  camera.position.set(100, 100, 100);\n  camera.lookAt(new THREE.Vector3(110, 110, 110));\n\n  // Setup camera controller\n  const controls = new THREE.OrbitControls(camera, context.canvas);\n  controls.target = new THREE.Vector3(0, 25, 0);\n\n  const scene = new THREE.Scene();\n\n  const gridHelper = new THREE.GridHelper(100, 20);\n  scene.add(gridHelper);\n\n  const light = new THREE.HemisphereLight(0xffffff, 0x000000, 1);\n  scene.add(light);\n\n  bunny.positions.forEach(i => {\n    i[0] *= 5;\n    i[1] *= 5;\n    i[2] *= 5;\n  });\n\n  const starsGeometry = new THREE.Geometry();\n\n  bunny.positions.forEach(i => {\n    starsGeometry.vertices.push(new THREE.Vector3(i[0], i[1], i[2]));\n  });\n  bunny.cells.forEach(i => {\n    starsGeometry.vertices.push(\n      new THREE.Vector3(\n        (bunny.positions[i[0]][0] + bunny.positions[i[1]][0] + bunny.positions[i[2]][0]) / 3,\n        (bunny.positions[i[0]][1] + bunny.positions[i[1]][1] + bunny.positions[i[2]][1]) / 3,\n        (bunny.positions[i[0]][2] + bunny.positions[i[1]][2] + bunny.positions[i[2]][2]) / 3,\n      ),\n    );\n  });\n\n  const shaderPoint = THREE.ShaderLib.points;\n  const uniforms = THREE.UniformsUtils.clone(shaderPoint.uniforms);\n  uniforms.time = {\n    value: 0,\n  };\n\n  const pMaterial = new THREE.ShaderMaterial({\n    uniforms,\n    transparent: true,\n    depthWrite: false,\n\n    blending: THREE.AdditiveBlending,\n\n    vertexShader,\n    fragmentShader,\n  });\n\n  const particles = new THREE.Points(starsGeometry, pMaterial);\n  scene.add(particles);\n\n  return {\n    resize({ pixelRatio, viewportWidth, viewportHeight }) {\n      renderer.setPixelRatio(pixelRatio);\n      renderer.setSize(viewportWidth, viewportHeight, false);\n      camera.aspect = viewportWidth / viewportHeight;\n      camera.updateProjectionMatrix();\n    },\n\n    render({ time }) {\n      pMaterial.uniforms.time.value = time * 10;\n\n      controls.update();\n      renderer.render(scene, camera);\n    },\n\n    unload() {\n      controls.dispose();\n      renderer.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}