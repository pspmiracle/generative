{"version":3,"sources":["unreleased/particles_tornado/shaders/vert.glsl","unreleased/particles_tornado/shaders/frag.glsl","unreleased/particles_tornado/index.js"],"names":["sketch","a","canvas","width","height","engine","BABYLON","preserveDrawingBuffer","stencil","scene","clearColor","FromHexString","ShadersStore","particlesVertexShader","particlesFragmentShader","particlesFragShader","camera","Math","PI","attachControl","pcs","generateParticles","particle","i","s","ptAngle","random","ptRadiusSq","x","sqrt","cos","y","sin","position","addPoints","buildMeshAsync","particlesMaterial","vertex","fragment","attributes","uniforms","needAlphaBlending","pointsCloud","alphaMode","ALPHA_SCREENMODE","setFloat","mesh","material","render","time","aRatio","getEngine","getAspectRatio","setVector2","setVector3","resize","pixelRatio","unload","dispose","settings","animate","context"],"mappings":"mHAAA,OAAe,ygE,iCCAf,OAAe,ytB,+FCSTA,EAAM,uCAAG,yCAAAC,EAAA,6DAASC,EAAT,EAASA,OAAT,EAAiBC,MAAjB,EAAwBC,OAC/BC,EAAS,IAAIC,SAAeJ,GAAQ,EAAM,CAC9CK,uBAAuB,EACvBC,SAAS,KAILC,EAAQ,IAAIH,QAAcD,IAC1BK,WAAaJ,SAAeK,cAAc,WAEhDL,SAAeM,aAAaC,sBAAwBA,UACpDP,SAAeM,aAAaE,wBAA0BC,WAGhDC,EAAS,IAAIV,kBACjB,WACCW,KAAKC,GAAK,EACXD,KAAKC,GAAK,EACV,GACA,IAAIZ,UAAgB,EAAG,EAAG,GAC1BG,IAIKU,cAAcjB,GAAQ,GAEvBkB,EAAM,IAAId,oBAA0B,MAAO,EAAGG,GAE9CY,EAAoB,SAACC,EAAUC,EAAGC,GACtC,IACMC,EAA0B,EAAhBR,KAAKS,SAAeT,KAAKC,GACnCS,EAFS,GAEIV,KAAKS,SAFT,GAGTE,EAAIX,KAAKY,KAAKF,GAAcV,KAAKa,IAAIL,GACrCM,EAAId,KAAKY,KAAKF,GAAcV,KAAKe,IAAIP,GAE3CH,EAASW,SAAW,IAAI3B,UAAgBsB,EAAG,EAAGG,IAEhDX,EAAIc,UAAU,IAAQb,GArCT,UAuCPD,EAAIe,iBAvCG,eAyCPC,EAAoB,IAAI9B,iBAC5B,SACAG,EACA,CACE4B,OAAQ,YACRC,SAAU,aAEZ,CACEC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,QAAS,YAAa,sBAAuB,OAAQ,QAAS,cAAe,QAAS,UACjGC,mBAAmB,KAGLC,aAAc,EAEhCN,EAAkBO,UAAYrC,SAAesC,iBAG7CR,EAAkBS,SAAS,cAAe,IAAIvC,UAAgB,EAAG,IACjE8B,EAAkBS,SAAS,QAAS,GAEpCzB,EAAI0B,KAAKC,SAAWX,EA9DP,kBAgEN,CACLY,OADK,YACa,IAATC,EAAQ,EAARA,KACPb,EAAkBS,SAAS,QAASI,GACpC,IAAMC,EAASzC,EAAM0C,YAAYC,eAAepC,GAChDoB,EAAkBiB,WAAW,cAAe,IAAI/C,UAAgB4C,EAAQ,IACxEd,EAAkBkB,WAAW,SAAUtC,EAAOiB,UAE9CxB,EAAMuC,UAERO,OATK,YASiC,EAA7BC,WAA6B,EAAjBrD,MAAiB,EAAVC,OAC1BC,EAAOkD,UAETE,OAZK,WAaHpD,EAAOqD,aA7EE,4CAAH,sDAkFG,WAAE1D,SAAQ2D,SAvFR,CACfC,SAAS,EACTC,QAAS","file":"static/js/49.2fce712a.chunk.js","sourcesContent":["export default \"#define GLSLIFY 1\\nattribute vec3 position;\\nattribute vec2 uv;\\n\\nvarying vec2 vUv;\\nvarying vec3 oPos;\\nvarying vec3 pPos;\\nvarying float rSize;\\n\\nuniform float iTime;\\nuniform float pSize;\\nuniform vec3 camPos;\\n\\nuniform mat4 worldViewProjection;\\nuniform mat4 world;\\n\\n#define PI 3.1415926;\\n#define PI2 6.28318530;\\n#define MOD3 vec3(.1031, .11369, .13787)\\n#define rand1(p) fract(sin(p * 78.233) * 43758.5453)\\n\\nvec3 hash33(vec3 p3)\\n{\\n    p3 = fract(p3 * MOD3);\\n    p3 += dot(p3, p3.yxz + 19.19);\\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\\n}\\n\\nfloat noise(vec3 p)\\n{\\n    const float K1 = 0.333333333;\\n    const float K2 = 0.166666667;\\n\\n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\\n\\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\\n    vec3 i1 = e * (1.0 - e.zxy);\\n    vec3 i2 = 1.0 - e.zxy * (1.0 - e);\\n\\n    vec3 d1 = d0 - (i1 - 1.0 * K2);\\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\\n\\n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\\n\\n    return dot(vec4(31.316), n);\\n}\\n\\nvoid main()\\n{\\n    vUv = uv;\\n\\n    oPos = position;\\n    pPos = position;\\n\\n    float t = fract(iTime / 5.) * 5.;\\n    float f = noise(oPos * .5);\\n\\n    float moveFactor = (oPos.z * .02 - (t * .5 + f * .3)) * (10. + (pPos.y - oPos.y + 50.) * 1.) * t * step(pPos.z * .02, t * .5 + f * .3);\\n\\n    float l = length(oPos.xz);\\n    float rp = iTime * abs(oPos.x * .05) + rand1(oPos.x) * PI2 + rand1(oPos.z * 100.) * PI2;\\n    pPos.x = cos(rp) * l;\\n    pPos.z = sin(rp) * l;\\n    pPos.y += (rand1(oPos.x + oPos.z) - .5) * 20.;\\n\\n    float camLength = clamp(length(camPos - pPos), 0., 100.);\\n\\n    rSize = 100. / (camLength * 0.65);\\n\\n    gl_PointSize = rSize * 2.;\\n\\n    gl_Position = worldViewProjection * vec4(pPos, 1.0);\\n}\\n\";","export default \"#define GLSLIFY 1\\nvarying vec3 oPos;\\nvarying vec3 pPos;\\nvarying float rSize;\\n\\nvarying vec2 vUv;\\n\\nuniform vec2 iResolution;\\nuniform float iTime;\\n\\n// #define hue(h) clamp( abs( fract(h + vec4(3,2,1,0)/3.) * 6. - 3.) -1. , 0., 1.)\\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\\n\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\\n{\\n  vec2 uv = (vec3(gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1)).xy - .5;\\n\\n  vec3 col = hue(fract(oPos.z)*.4 + .45).rgb;\\n\\n  float l = length(uv);\\n  float rsx = clamp(rSize/10., 0., .5);\\n  float g = smoothstep(.5, .45 - rsx, l);\\n\\n  fragColor = vec4(col * g, 1.-rsx*.1);\\n}\\n\\nvoid main()\\n{\\n  mainImage(gl_FragColor, vUv * iResolution.xy);\\n}\\n\";","import * as BABYLON from 'babylonjs';\nimport particlesVertexShader from './shaders/vert.glsl';\nimport particlesFragShader from './shaders/frag.glsl';\n\nconst settings = {\n  animate: true,\n  context: 'webgl',\n};\n\nconst sketch = async ({ canvas, width, height }) => {\n  const engine = new BABYLON.Engine(canvas, true, {\n    preserveDrawingBuffer: true,\n    stencil: true,\n  });\n\n  // This creates a basic Babylon Scene object (non-mesh)\n  const scene = new BABYLON.Scene(engine);\n  scene.clearColor = BABYLON.Color3.FromHexString('#182026');\n\n  BABYLON.Effect.ShadersStore.particlesVertexShader = particlesVertexShader;\n  BABYLON.Effect.ShadersStore.particlesFragmentShader = particlesFragShader;\n\n  // This creates and positions a free camera (non-mesh)\n  const camera = new BABYLON.ArcRotateCamera(\n    'camera1',\n    -Math.PI / 2,\n    Math.PI / 2,\n    50,\n    new BABYLON.Vector3(0, 0, 0),\n    scene,\n  );\n\n  // This attaches the camera to the canvas\n  camera.attachControl(canvas, true);\n\n  const pcs = new BABYLON.PointsCloudSystem('pcs', 0, scene);\n\n  const generateParticles = (particle, i, s) => {\n    const radius = 50;\n    const ptAngle = Math.random() * 2 * Math.PI;\n    const ptRadiusSq = Math.random() * radius * radius;\n    const x = Math.sqrt(ptRadiusSq) * Math.cos(ptAngle);\n    const y = Math.sqrt(ptRadiusSq) * Math.sin(ptAngle);\n\n    particle.position = new BABYLON.Vector3(x, 0, y);\n  };\n  pcs.addPoints(100000, generateParticles);\n\n  await pcs.buildMeshAsync();\n\n  const particlesMaterial = new BABYLON.ShaderMaterial(\n    'shader',\n    scene,\n    {\n      vertex: 'particles',\n      fragment: 'particles',\n    },\n    {\n      attributes: ['position', 'normal', 'uv'],\n      uniforms: ['world', 'worldView', 'worldViewProjection', 'view', 'iTime', 'iResolution', 'pSize', 'camPos'],\n      needAlphaBlending: true,\n    },\n  );\n  particlesMaterial.pointsCloud = true;\n\n  particlesMaterial.alphaMode = BABYLON.Engine.ALPHA_SCREENMODE;\n  // particlesMaterial.alphaMode = 5.;\n\n  particlesMaterial.setFloat('iResolution', new BABYLON.Vector2(1, 1));\n  particlesMaterial.setFloat('pSize', 2);\n\n  pcs.mesh.material = particlesMaterial;\n\n  return {\n    render({ time }) {\n      particlesMaterial.setFloat('iTime', time);\n      const aRatio = scene.getEngine().getAspectRatio(camera);\n      particlesMaterial.setVector2('iResolution', new BABYLON.Vector2(aRatio, 1));\n      particlesMaterial.setVector3('camPos', camera.position);\n\n      scene.render();\n    },\n    resize({ pixelRatio, width, height }) {\n      engine.resize();\n    },\n    unload() {\n      engine.dispose();\n    },\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}