{"version":3,"sources":["utils/ctx.js","sketches/006_ragged_canvas/index.js"],"names":["setDrawPolygon","context","lineCoords","closePath","beginPath","i","length","p","moveTo","lineTo","drawLine","stroke","size","settings","dimensions","animate","sketch","a","canvas","makeSepLine","vertical","sepLine","k0","random","range","k1","x","push","y","lineWidth","bufCanvas","document","createElement","width","height","copyCanvas","getContext","drawImage","prevSeparationTime","setFillColor","fillColor","time","fillStyle","fillRect","move","save","area","map","si","clip","restore"],"mappings":"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","file":"static/js/50.8ca748bc.chunk.js","sourcesContent":["export function setDrawPolygon(context, lineCoords, closePath = false) {\n  context.beginPath();\n  for (let i = 0; i < lineCoords.length; i += 1) {\n    const p = lineCoords[i];\n    if (i === 0) {\n      context.moveTo(p[0], p[1]);\n    } else {\n      context.lineTo(p[0], p[1]);\n    }\n  }\n  if (closePath) {\n    context.closePath();\n  }\n}\n\nexport const drawLine = (context, lineCoords, closePath = false) => {\n  setDrawPolygon(context, lineCoords, closePath);\n  context.stroke();\n};\n\nexport function setPixel(imgData, x, y, cR, cG, cB, cA = 255) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  imgData.data[n] = ~~cR;\n  imgData.data[n + 1] = ~~cG;\n  imgData.data[n + 2] = ~~cB;\n  imgData.data[n + 3] = ~~cA;\n}\n\nconst resultGetPixelArray = [0, 0, 0, 0];\nexport function getPixel(imgData, x, y, colorNumber) {\n  const n = (~~x + ~~y * imgData.width) * 4;\n\n  if (colorNumber !== undefined) {\n    return imgData.data[n + colorNumber];\n  }\n\n  for (let i = 0; i < 4; i += 1) {\n    resultGetPixelArray[i] = n + i;\n  }\n  return resultGetPixelArray;\n}\n","import random from 'canvas-sketch-util/random';\nimport { drawLine, setDrawPolygon } from '@/utils/ctx';\n\nconst size = 1024;\n\nconst settings = {\n  dimensions: [size, size],\n  animate: true,\n};\n\nconst sketch = async ({ context, canvas }) => {\n  let vertical = true;\n\n  let sepLine;\n\n  const makeSepLine = vertical => {\n    sepLine = [];\n    const k0 = random.range(size * 0.1, size * 0.9);\n    const k1 = random.range(size * 0.1, size * 0.9);\n\n    if (vertical) {\n      for (let i = 0; i <= size + 10; i += 10) {\n        const x = k0 + (k1 - k0) * (i / size);\n        sepLine.push([x + random.range(-5, +5), i]);\n      }\n    } else {\n      for (let i = 0; i <= size + 10; i += 10) {\n        const y = k0 + (k1 - k0) * (i / size);\n        sepLine.push([i, y + random.range(-5, +5)]);\n      }\n    }\n\n    context.lineWidth = 4;\n    drawLine(context, sepLine);\n  };\n  makeSepLine(vertical);\n\n  const bufCanvas = document.createElement('canvas');\n  bufCanvas.width = size;\n  bufCanvas.height = size;\n\n  const copyCanvas = () => {\n    bufCanvas.getContext('2d').drawImage(canvas, 0, 0);\n  };\n\n  copyCanvas();\n\n  let prevSeparationTime = 0;\n  let fillColor;\n  const setFillColor = () => {\n    fillColor = `hsl(${random.range(0, 360)}, 100%,80%)`;\n  };\n  setFillColor();\n\n  return ({ context, time }) => {\n    if (time - prevSeparationTime > random.range(0.08, 0.3)) {\n      vertical = !vertical;\n      prevSeparationTime = time;\n      setFillColor();\n      makeSepLine(vertical);\n      copyCanvas();\n    } else {\n      context.fillStyle = fillColor;\n      context.fillRect(0, 0, size, size);\n    }\n\n    const move = (time - prevSeparationTime) * 400;\n\n    if (vertical) {\n      for (let i = 0; i < 2; i += 1) {\n        context.save();\n\n        let area;\n        if (i === 0) {\n          area = [[0, 0], ...sepLine.map(si => [si[0] - move, si[1]]), [0, size]];\n        } else {\n          area = [[size, 0], ...sepLine.map(si => [si[0] + move, si[1]]), [size, size]];\n        }\n\n        setDrawPolygon(context, area, true);\n        context.clip();\n\n        if (i === 0) {\n          context.drawImage(bufCanvas, -move, 0);\n        } else {\n          context.drawImage(bufCanvas, +move, 0);\n        }\n\n        context.restore();\n      }\n    } else {\n      for (let i = 0; i < 2; i += 1) {\n        context.save();\n\n        let area;\n        if (i === 0) {\n          area = [[0, 0], ...sepLine.map(si => [si[0], si[1] - move]), [size, 0]];\n        } else {\n          area = [[0, size], ...sepLine.map(si => [si[0], si[1] + move]), [size, size]];\n        }\n\n        setDrawPolygon(context, area, true);\n        context.clip();\n\n        if (i === 0) {\n          context.drawImage(bufCanvas, 0, -move);\n        } else {\n          context.drawImage(bufCanvas, 0, +move);\n        }\n\n        context.restore();\n      }\n    }\n  };\n};\n\nexport default { sketch, settings };\n"],"sourceRoot":""}